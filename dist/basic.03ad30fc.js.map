{"version":3,"sources":["../dist-src/component.js","../dist-src/entity.js","../dist-src/system.js","../dist-src/bitset.js","../dist-src/component-map.js","../dist-src/world.js","../src/mainloop.js","shared/components/color.ts","shared/components/rectangle.ts","shared/vector2.ts","shared/components/transform.ts","shared/components/velocity.ts","shared/components/index.ts","basic/components/ball-tag.ts","basic/basic.ts"],"names":["this","root","timestamp","rafHandle","requestAnimationFrame","animate","lastFrameTimeMs","minFrameDelay","frameDelta","begin","lastFpsUpdate","fpsUpdateInterval","fps","fpsAlpha","framesSinceLastFpsUpdate","numUpdateSteps","simulationTimestep","update","panic","draw","end","running","started","windowOrRoot","window","now","timeout","Date","callback","Math","max","lastTimestamp","setTimeout","cancelAnimationFrame","clearTimeout","NOOP","MainLoop","getSimulationTimestep","setSimulationTimestep","timestep","getFPS","getMaxAllowedFPS","setMaxAllowedFPS","Infinity","stop","resetFrameDelta","oldFrameDelta","setBegin","fun","setUpdate","setDraw","setEnd","start","isRunning","define","amd","module","exports"],"mappings":"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","file":"basic.03ad30fc.js","sourceRoot":"..","sourcesContent":["import { BitSet } from './bitset';\nfunction* bitmaskGenerator() {\n    let n = 1;\n    while (true) {\n        const mask = new BitSet(n);\n        mask.set(n - 1);\n        ++n;\n        yield mask;\n    }\n}\nexport class Component {\n    constructor() {\n        // tslint:disable-next-line: variable-name\n        this.__component = true;\n    }\n    static get bitmask() {\n        if (this._bitmask == null) {\n            this._bitmask = this._bitmaskGenerator.next().value;\n        }\n        return this._bitmask;\n    }\n}\nComponent._bitmaskGenerator = bitmaskGenerator();\n","/**\n * Representation of a unique entity value within the world\n */\nexport class Entity {\n    constructor(id) {\n        this.id = id;\n        this.version = 0;\n    }\n}\n","/**\n * Class for all Systems to derive from\n */\nexport class System {\n}\n","// Matt Krick, matt.krick@gmail.com, MIT License\n// each bin holds bits 0 - 30, totaling 31 (sign takes up last bit)\nexport const BITS_PER_INT = 31;\n// used for ffs of a word in O(1) time. LUTs get a bad wrap, they are fast.\nexport const multiplyDeBruijnBitPosition = [\n    0,\n    1,\n    28,\n    2,\n    29,\n    14,\n    24,\n    3,\n    30,\n    22,\n    20,\n    15,\n    25,\n    17,\n    4,\n    8,\n    31,\n    27,\n    13,\n    23,\n    21,\n    19,\n    16,\n    7,\n    26,\n    12,\n    18,\n    6,\n    11,\n    5,\n    10,\n    9,\n];\nexport class BitSet {\n    /**\n     * Create a new bitset. Accepts either the maximum number of bits, or a dehydrated bitset\n     * @param {number|string} nBitsOrKey - Number of bits in the set or dehydrated bitset.\n     * For speed and space concerns, the initial number of bits cannot be increased.\n     * @constructor\n     */\n    constructor(nBitsOrKey) {\n        this.MAX_BIT = 0;\n        let wordCount;\n        let arrVals;\n        let front;\n        let leadingZeros;\n        let i;\n        if (typeof nBitsOrKey === 'number') {\n            nBitsOrKey = nBitsOrKey || BITS_PER_INT; // default to 1 word\n            wordCount = Math.ceil(nBitsOrKey / BITS_PER_INT);\n            this.arr = new Uint32Array(wordCount);\n            this.MAX_BIT = nBitsOrKey - 1;\n        }\n        else {\n            arrVals = JSON.parse('[' + nBitsOrKey + ']');\n            this.MAX_BIT = arrVals.pop();\n            leadingZeros = arrVals.pop();\n            if (leadingZeros > 0) {\n                front = [];\n                for (i = 0; i < leadingZeros; i++) {\n                    front[i] = 0;\n                }\n                for (i = 0; i < arrVals.length; i++) {\n                    front[leadingZeros + i] = arrVals[i];\n                }\n                arrVals = front;\n            }\n            wordCount = Math.ceil((this.MAX_BIT + 1) / BITS_PER_INT);\n            this.arr = new Uint32Array(wordCount);\n            this.arr.set(arrVals);\n        }\n    }\n    /**\n     * Check whether a bit at a specific index is set\n     * @param {number} idx the position of a single bit to check\n     * @returns {boolean} true if bit is set, else false\n     */\n    get(idx) {\n        const word = this.getWord(idx);\n        return word === -1\n            ? false\n            : ((this.arr[word] >> idx % BITS_PER_INT) & 1) === 1;\n    }\n    /**\n     * Set a single bit\n     * @param {number} idx the position of a single bit to set\n     * @returns {boolean} true if set was successful, else false\n     */\n    set(idx) {\n        const word = this.getWord(idx);\n        if (word === -1) {\n            return false;\n        }\n        this.arr[word] |= 1 << idx % BITS_PER_INT;\n        return true;\n    }\n    /**\n     * Set a range of bits\n     * @param {number} from the starting index of the range to set\n     * @param {number} to the ending index of the range to set\n     * @returns {boolean} true if set was successful, else false\n     */\n    setRange(from, to) {\n        return this.doRange(from, to, setFunc);\n    }\n    /**\n     * Unset a single bit\n     * @param {number} idx the position of a single bit to unset\n     * @returns {boolean} true if set was successful, else false\n     */\n    unset(idx) {\n        const word = this.getWord(idx);\n        if (word === -1) {\n            return false;\n        }\n        this.arr[word] &= ~(1 << idx % BITS_PER_INT);\n        return true;\n    }\n    /**\n     * Toggle a single bit\n     * @param {number} idx the position of a single bit to toggle\n     * @returns {boolean} true if set was successful, else false\n     */\n    toggle(idx) {\n        const word = this.getWord(idx);\n        if (word === -1) {\n            return false;\n        }\n        this.arr[word] ^= 1 << idx % BITS_PER_INT;\n        return true;\n    }\n    /**\n     * Toggle a range of bits\n     * @param {number} from the starting index of the range to toggle\n     * @param {number} to the ending index of the range to toggle\n     * @returns {boolean} true if set was successful, else false\n     */\n    toggleRange(from, to) {\n        return this.doRange(from, to, toggleFunc);\n    }\n    /**\n     *\n     * Clear an entire bitset\n     * @returns {boolean} true\n     */\n    clear() {\n        for (let i = 0; i < this.arr.length; i++) {\n            this.arr[i] = 0;\n        }\n        return true;\n    }\n    /**\n     * Clone a bitset\n     * @returns {BitSet} an copy (by value) of the calling bitset\n     */\n    clone() {\n        return new BitSet(this.dehydrate());\n    }\n    /**\n     *\n     * Turn the bitset into a comma separated string that skips leading & trailing 0 words.\n     * Ends with the number of leading 0s and MAX_BIT.\n     * Useful if you need the bitset to be an object key (eg dynamic programming).\n     * Can rehydrate by passing the result into the constructor\n     * @returns {string} representation of the bitset\n     */\n    dehydrate() {\n        let i;\n        let lastUsedWord = 0;\n        let s;\n        let leadingZeros = 0;\n        for (i = 0; i < this.arr.length; i++) {\n            if (this.arr[i] !== 0) {\n                break;\n            }\n            leadingZeros++;\n        }\n        for (i = this.arr.length - 1; i >= leadingZeros; i--) {\n            if (this.arr[i] !== 0) {\n                lastUsedWord = i;\n                break;\n            }\n        }\n        s = '';\n        for (i = leadingZeros; i <= lastUsedWord; i++) {\n            s += this.arr[i] + ',';\n        }\n        s += leadingZeros + ',' + this.MAX_BIT; // leading 0s, stop numbers\n        return s;\n    }\n    /**\n     *\n     * Perform a bitwise AND on 2 bitsets or 1 bitset and 1 index.\n     * Both bitsets must have the same number of words, no length check is performed to prevent and overflow.\n     * @param {BitSet | Number} bsOrIdx a bitset or single index to check (useful for LP, DP problems)\n     * @returns {BitSet} a new bitset that is the bitwise AND of the two\n     */\n    and(bsOrIdx) {\n        return this.op(bsOrIdx, and);\n    }\n    /**\n     *\n     * Perform a bitwise OR on 2 bitsets or 1 bitset and 1 index.\n     * Both bitsets must have the same number of words, no length check is performed to prevent and overflow.\n     * @param {BitSet | Number} bsOrIdx a bitset or single index to check (useful for LP, DP problems)\n     * @returns {BitSet} a new bitset that is the bitwise OR of the two\n     */\n    or(bsOrIdx) {\n        return this.op(bsOrIdx, or);\n    }\n    /**\n     *\n     * Perform a bitwise XOR on 2 bitsets or 1 bitset and 1 index.\n     * Both bitsets must have the same number of words, no length check is performed to prevent and overflow.\n     * @param {BitSet | Number} bsOrIdx a bitset or single index to check (useful for LP, DP problems)\n     * @returns {BitSet} a new bitset that is the bitwise XOR of the two\n     */\n    xor(bsOrIdx) {\n        return this.op(bsOrIdx, xor);\n    }\n    /**\n     * Run a custom function on every set bit. Faster than iterating over the entire bitset with a `get()`\n     * Source code includes a nice pattern to follow if you need to break the for-loop early\n     * @param {Function} func the function to pass the next set bit to\n     */\n    // tslint:disable-next-line: ban-types\n    forEach(func) {\n        for (let i = this.ffs(); i !== -1; i = this.nextSetBit(i + 1)) {\n            func(i);\n        }\n    }\n    /**\n     * Circular shift bitset by an offset\n     * @param {Number} number of positions that the bitset that will be shifted to the right.\n     * Using a negative number will result in a left shift.\n     * @returns {Bitset} a new bitset that is rotated by the offset\n     */\n    circularShift(offset) {\n        offset = -offset;\n        const S = this; // source BitSet (this)\n        const MASK_SIGN = 0x7fffffff;\n        const BITS = S.MAX_BIT + 1;\n        const WORDS = S.arr.length;\n        const BITS_LAST_WORD = BITS_PER_INT - (WORDS * BITS_PER_INT - BITS);\n        const T = new BitSet(BITS); // target BitSet (the shifted bitset)\n        let t = 0; // (s)ource and (t)arget word indices\n        let j = 0; // current bit indices for source (i) and target (j) words\n        let z = 0; // bit index for entire sequence.\n        offset = (BITS + (offset % BITS)) % BITS; // positive, within length\n        let s = ~~(offset / BITS_PER_INT) % WORDS;\n        let i = offset % BITS_PER_INT;\n        while (z < BITS) {\n            const sourceWordLength = s === WORDS - 1 ? BITS_LAST_WORD : BITS_PER_INT;\n            let bits = S.arr[s];\n            if (i > 0) {\n                bits = bits >>> i;\n            }\n            if (j > 0) {\n                bits = bits << j;\n            }\n            T.arr[t] = T.arr[t] | bits;\n            const bitsAdded = Math.min(BITS_PER_INT - j, sourceWordLength - i);\n            z += bitsAdded;\n            j += bitsAdded;\n            if (j >= BITS_PER_INT) {\n                T.arr[t] = T.arr[t] & MASK_SIGN;\n                j = 0;\n                t++;\n            }\n            i += bitsAdded;\n            if (i >= sourceWordLength) {\n                i = 0;\n                s++;\n            }\n            if (s >= WORDS) {\n                s -= WORDS;\n            }\n        }\n        T.arr[WORDS - 1] =\n            T.arr[WORDS - 1] & (MASK_SIGN >>> (BITS_PER_INT - BITS_LAST_WORD));\n        return T;\n    }\n    /**\n     * Get the cardinality (count of set bits) for the entire bitset\n     * @returns {number} cardinality\n     */\n    getCardinality() {\n        let setCount = 0;\n        for (let i = this.arr.length - 1; i >= 0; i--) {\n            let j = this.arr[i];\n            j = j - ((j >> 1) & 0x55555555);\n            j = (j & 0x33333333) + ((j >> 2) & 0x33333333);\n            setCount += (((j + (j >> 4)) & 0x0f0f0f0f) * 0x01010101) >> 24;\n        }\n        return setCount;\n    }\n    /**\n     * Get the indices of all set bits. Useful for debugging, uses `forEach` internally\n     * @returns {Array} Indices of all set bits\n     */\n    getIndices() {\n        const indices = [];\n        this.forEach((i) => {\n            indices.push(i);\n        });\n        return indices;\n    }\n    /**\n     * Checks if one bitset is subset of another. Same thing can be done using _and_ operation and equality check,\n     * but then new BitSet would be created, and if one is only interested in yes/no information it would be a waste\n     * of memory and additional GC strain.\n     * @param {BitSet} bs a bitset to check\n     * @returns {Boolean} `true` if provided bitset is a subset of this bitset, `false` otherwise\n     */\n    isSubsetOf(bs) {\n        const arr1 = this.arr;\n        const arr2 = bs.arr;\n        const len = arr1.length;\n        for (let i = 0; i < len; i++) {\n            if ((arr1[i] & arr2[i]) !== arr1[i]) {\n                return false;\n            }\n        }\n        return true;\n    }\n    /**\n     * Quickly determine if a bitset is empty\n     * @returns {boolean} true if the entire bitset is empty, else false\n     */\n    isEmpty() {\n        let i;\n        let arr;\n        arr = this.arr;\n        for (i = 0; i < arr.length; i++) {\n            if (arr[i]) {\n                return false;\n            }\n        }\n        return true;\n    }\n    /**\n     *\n     * Quickly determine if both bitsets are equal (faster than checking if the XOR of the two is === 0).\n     * Both bitsets must have the same number of words, no length check is performed to prevent and overflow.\n     * @param {BitSet} bs\n     * @returns {boolean} true if the entire bitset is empty, else false\n     */\n    isEqual(bs) {\n        let i;\n        for (i = 0; i < this.arr.length; i++) {\n            if (this.arr[i] !== bs.arr[i]) {\n                return false;\n            }\n        }\n        return true;\n    }\n    /**\n     * Get a string representation of the entire bitset, including leading 0s (useful for debugging)\n     * @returns {string} a base 2 representation of the entire bitset\n     */\n    toString() {\n        let i;\n        let str;\n        let fullString = '';\n        for (i = this.arr.length - 1; i >= 0; i--) {\n            str = this.arr[i].toString(2);\n            fullString += ('0000000000000000000000000000000' + str).slice(-BITS_PER_INT);\n        }\n        return fullString;\n    }\n    /**\n     * Find first set bit (useful for processing queues, breadth-first tree searches, etc.)\n     * @param {number} startWord the word to start with (only used internally by nextSetBit)\n     * @returns {number} the index of the first set bit in the bitset, or -1 if not found\n     */\n    ffs(startWord = 0) {\n        let setVal;\n        let i;\n        let fs = -1;\n        for (i = startWord; i < this.arr.length; i++) {\n            setVal = this.arr[i];\n            if (setVal === 0) {\n                continue;\n            }\n            fs = lsb(setVal) + i * BITS_PER_INT;\n            break;\n        }\n        return fs <= this.MAX_BIT ? fs : -1;\n    }\n    /**\n     * Find first zero (unset bit)\n     * @param {number} startWord the word to start with (only used internally by nextUnsetBit)\n     * @returns {number} the index of the first unset bit in the bitset, or -1 if not found\n     */\n    ffz(startWord) {\n        let i;\n        let setVal;\n        let fz = -1;\n        startWord = startWord || 0;\n        for (i = startWord; i < this.arr.length; i++) {\n            setVal = this.arr[i];\n            if (setVal === 0x7fffffff) {\n                continue;\n            }\n            setVal ^= 0x7fffffff;\n            fz = lsb(setVal) + i * BITS_PER_INT;\n            break;\n        }\n        return fz <= this.MAX_BIT ? fz : -1;\n    }\n    /**\n     *\n     * Find last set bit\n     * @param {number} startWord the word to start with (only used internally by previousSetBit)\n     * @returns {number} the index of the last set bit in the bitset, or -1 if not found\n     */\n    fls(startWord = this.arr.length - 1) {\n        let i;\n        let setVal;\n        let ls = -1;\n        for (i = startWord; i >= 0; i--) {\n            setVal = this.arr[i];\n            if (setVal === 0) {\n                continue;\n            }\n            ls = msb(setVal) + i * BITS_PER_INT;\n            break;\n        }\n        return ls;\n    }\n    /**\n     *\n     * Find last zero (unset bit)\n     * @param {number} startWord the word to start with (only used internally by previousUnsetBit)\n     * @returns {number} the index of the last unset bit in the bitset, or -1 if not found\n     */\n    flz(startWord) {\n        let i;\n        let setVal;\n        let ls = -1;\n        if (startWord === undefined) {\n            startWord = this.arr.length - 1;\n        }\n        for (i = startWord; i >= 0; i--) {\n            setVal = this.arr[i];\n            if (i === this.arr.length - 1) {\n                const wordIdx = this.MAX_BIT % BITS_PER_INT;\n                const unusedBitCount = BITS_PER_INT - wordIdx - 1;\n                setVal |= ((1 << unusedBitCount) - 1) << (wordIdx + 1);\n            }\n            if (setVal === 0x7fffffff) {\n                continue;\n            }\n            setVal ^= 0x7fffffff;\n            ls = msb(setVal) + i * BITS_PER_INT;\n            break;\n        }\n        return ls;\n    }\n    /**\n     * Find first set bit, starting at a given index\n     * @param {number} idx the starting index for the next set bit\n     * @returns {number} the index of the next set bit >= idx, or -1 if not found\n     */\n    nextSetBit(idx) {\n        const startWord = this.getWord(idx);\n        if (startWord === -1) {\n            return -1;\n        }\n        const wordIdx = idx % BITS_PER_INT;\n        const len = BITS_PER_INT - wordIdx;\n        const mask = ((1 << len) - 1) << wordIdx;\n        const reducedWord = this.arr[startWord] & mask;\n        if (reducedWord > 0) {\n            return lsb(reducedWord) + startWord * BITS_PER_INT;\n        }\n        return this.ffs(startWord + 1);\n    }\n    /**\n     * Find first unset bit, starting at a given index\n     * @param {number} idx the starting index for the next unset bit\n     * @returns {number} the index of the next unset bit >= idx, or -1 if not found\n     */\n    nextUnsetBit(idx) {\n        const startWord = this.getWord(idx);\n        if (startWord === -1) {\n            return -1;\n        }\n        const mask = (1 << idx % BITS_PER_INT) - 1;\n        const reducedWord = this.arr[startWord] | mask;\n        if (reducedWord === 0x7fffffff) {\n            return this.ffz(startWord + 1);\n        }\n        return lsb(0x7fffffff ^ reducedWord) + startWord * BITS_PER_INT;\n    }\n    /**\n     * Find last set bit, up to a given index\n     * @param {number} idx the starting index for the next unset bit (going in reverse)\n     * @returns {number} the index of the next unset bit <= idx, or -1 if not found\n     */\n    previousSetBit(idx) {\n        const startWord = this.getWord(idx);\n        if (startWord === -1) {\n            return -1;\n        }\n        const mask = 0x7fffffff >>> (BITS_PER_INT - (idx % BITS_PER_INT) - 1);\n        const reducedWord = this.arr[startWord] & mask;\n        if (reducedWord > 0) {\n            return msb(reducedWord) + startWord * BITS_PER_INT;\n        }\n        return this.fls(startWord - 1);\n    }\n    /**\n     * Find last unset bit, up to a given index\n     * @param {number} idx the starting index for the next unset bit (going in reverse)\n     * @returns {number} the index of the next unset bit <= idx, or -1 if not found\n     */\n    previousUnsetBit(idx) {\n        const startWord = this.getWord(idx);\n        if (startWord === -1) {\n            return -1;\n        }\n        const wordIdx = idx % BITS_PER_INT;\n        const mask = ((1 << (BITS_PER_INT - wordIdx - 1)) - 1) << (wordIdx + 1);\n        const reducedWord = this.arr[startWord] | mask;\n        if (reducedWord === 0x7fffffff) {\n            return this.flz(startWord - 1);\n        }\n        return msb(0x7fffffff ^ reducedWord) + startWord * BITS_PER_INT;\n    }\n    /**\n     *\n     * @param {number} idx position of bit in bitset\n     * @returns {number} the word where the index is located, or -1 if out of range\n     * @private\n     */\n    getWord(idx) {\n        return idx < 0 || idx > this.MAX_BIT ? -1 : ~~(idx / BITS_PER_INT);\n    }\n    /**\n     * Shared function for setting, unsetting, or toggling a range of bits\n     * @param {number} from the starting index of the range to set\n     * @param {number} to the ending index of the range to set\n     * @param {Function} func function to run (set, unset, or toggle)\n     * @returns {boolean} true if set was successful, else false\n     * @private\n     */\n    // tslint:disable-next-line: ban-types\n    doRange(from, to, func) {\n        let i;\n        let curStart;\n        let curEnd;\n        let len;\n        if (to < from) {\n            to ^= from;\n            from ^= to;\n            to ^= from;\n        }\n        const startWord = this.getWord(from);\n        const endWord = this.getWord(to);\n        if (startWord === -1 || endWord === -1) {\n            return false;\n        }\n        for (i = startWord; i <= endWord; i++) {\n            curStart = i === startWord ? from % BITS_PER_INT : 0;\n            curEnd = i === endWord ? to % BITS_PER_INT : BITS_PER_INT - 1;\n            len = curEnd - curStart + 1;\n            this.arr[i] = func(this.arr[i], len, curStart);\n        }\n        return true;\n    }\n    /**\n     * Both bitsets must have the same number of words, no length check is performed to prevent and overflow.\n     * @param {BitSet | Number} bsOrIdx a bitset or single index to check (useful for LP, DP problems)\n     * @param {Function} func the operation to perform (and, or, xor)\n     * @returns {BitSet} a new bitset that is the bitwise operation of the two\n     * @private\n     */\n    // tslint:disable-next-line: ban-types\n    op(bsOrIdx, func) {\n        let i;\n        let arr1;\n        let arr2;\n        let len;\n        let newBS;\n        let word;\n        arr1 = this.arr;\n        if (typeof bsOrIdx === 'number') {\n            word = this.getWord(bsOrIdx);\n            newBS = this.clone();\n            if (word !== -1) {\n                newBS.arr[word] = func(arr1[word], 1 << bsOrIdx % BITS_PER_INT);\n            }\n        }\n        else {\n            arr2 = bsOrIdx.arr;\n            len = arr1.length;\n            newBS = new BitSet(this.MAX_BIT + 1);\n            for (i = 0; i < len; i++) {\n                newBS.arr[i] = func(arr1[i], arr2[i]);\n            }\n        }\n        return newBS;\n    }\n}\n/**\n *\n * Returns the least signifcant bit, or 0 if none set, so a prior check to see if the word > 0 is required\n * @param {number} word the current array\n * @returns {number} the index of the least significant bit in the current array\n */\nexport function lsb(word) {\n    return multiplyDeBruijnBitPosition[((word & -word) * 0x077cb531) >>> 27];\n}\n/**\n * Returns the least signifcant bit, or 0 if none set, so a prior check to see if the word > 0 is required\n * @param word the current array\n * @returns {number} the index of the most significant bit in the current array\n */\nexport function msb(word) {\n    word |= word >> 1;\n    word |= word >> 2;\n    word |= word >> 4;\n    word |= word >> 8;\n    word |= word >> 16;\n    word = (word >> 1) + 1;\n    return multiplyDeBruijnBitPosition[(word * 0x077cb531) >>> 27];\n}\nexport function toggleFunc(word, len, curStart) {\n    const mask = ((1 << len) - 1) << curStart;\n    return word ^ mask;\n}\nexport function setFunc(word, len, curStart) {\n    const mask = ((1 << len) - 1) << curStart;\n    return word | mask;\n}\nexport function unsetFunc(word, len, curStart) {\n    const mask = 0x7fffffff ^ (((1 << len) - 1) << curStart);\n    return word & mask;\n}\nexport function and(word1, word2) {\n    return word1 & word2;\n}\nexport function or(word1, word2) {\n    return word1 | word2;\n}\nexport function xor(word1, word2) {\n    return word1 ^ word2;\n}\n","import { BitSet } from './bitset';\nexport class ComponentMap {\n    constructor() {\n        this.bitmask = new BitSet(0);\n        this.map = new Map();\n    }\n    get(ctor) {\n        const component = this.map.get(ctor);\n        return component != null ? component : undefined;\n    }\n    set(...components) {\n        let mask = new BitSet(0);\n        for (const component of components) {\n            if (this.map.has(component.constructor) === false) {\n                mask = mask.or(component.constructor.bitmask);\n            }\n            this.map.set(component.constructor, component);\n        }\n        this.bitmask = this.bitmask.or(mask);\n    }\n    remove(...componentCtors) {\n        let mask = new BitSet(0);\n        for (const componentCtor of componentCtors) {\n            if (this.map.has(componentCtor)) {\n                mask = mask.or(componentCtor.bitmask);\n            }\n            this.map.delete(componentCtor);\n        }\n        this.bitmask = this.bitmask.xor(mask);\n    }\n    clear() {\n        this.map.clear();\n        this.bitmask.clear();\n    }\n    keys() {\n        return this.map.keys();\n    }\n    has(componentCtor) {\n        return this.map.has(componentCtor);\n    }\n    get size() {\n        return this.map.size;\n    }\n}\n","import { ComponentMap } from './component-map';\nimport { Entity } from './entity';\nexport function* entityIdGenerator() {\n    let id = 0;\n    while (true) {\n        ++id;\n        yield id;\n    }\n}\n/**\n * Container for Systems and Entities\n */\nexport class World {\n    /**\n     * Create a new World instance\n     * @param idGenerator Unique entity id generator\n     */\n    constructor(idGenerator = entityIdGenerator()) {\n        this.idGenerator = idGenerator;\n        this.systems = [];\n        this.systemsToRemove = [];\n        this.systemsToAdd = [];\n        this.entities = new Map();\n        this.deletedEntities = new Set();\n        this.componentEntities = new Map();\n    }\n    /**\n     * Update all world systems\n     * @param dt Delta time\n     */\n    update(dt) {\n        this.updateSystems(dt);\n    }\n    createEntity() {\n        if (this.deletedEntities.size > 0) {\n            const entity = this.deletedEntities.values().next().value;\n            this.deletedEntities.delete(entity);\n            return entity;\n        }\n        const entity = new Entity(this.idGenerator.next().value);\n        this.entities.set(entity, new ComponentMap());\n        return entity;\n    }\n    /**\n     * Delete an entity from the world. Entities can be recycled so do not rely\n     * on the deleted entity reference after deleting it.\n     * @param entity Entity to delete\n     */\n    deleteEntity(entity) {\n        if (this.deletedEntities.has(entity)) {\n            return false;\n        }\n        if (this.entities.has(entity)) {\n            const componentMap = this.entities.get(entity);\n            for (const ctor of componentMap.keys()) {\n                this.componentEntities.get(ctor).delete(entity);\n            }\n            componentMap.clear();\n            this.deletedEntities.add(entity);\n            return true;\n        }\n        return false;\n    }\n    findEntity(...componentCtors) {\n        if (componentCtors.length === 0) {\n            return undefined;\n        }\n        const hasAllComponents = componentCtors.every(ctor => this.componentEntities.has(ctor));\n        if (hasAllComponents === false) {\n            return undefined;\n        }\n        const componentSets = componentCtors.map(ctor => this.componentEntities.get(ctor));\n        const smallestComponentSet = componentSets.reduce((smallest, set) => {\n            if (smallest == null) {\n                smallest = set;\n            }\n            else if (set.size < smallest.size) {\n                smallest = set;\n            }\n            return smallest;\n        });\n        const otherComponentSets = componentSets.filter(set => set !== smallestComponentSet);\n        for (const entity of smallestComponentSet.values()) {\n            const hasAll = otherComponentSets.every(set => set.has(entity));\n            if (hasAll === true) {\n                return entity;\n            }\n        }\n    }\n    addEntityComponents(entity, ...components) {\n        if (this.deletedEntities.has(entity)) {\n            throw new Error('Entity has been deleted');\n        }\n        const entityComponents = this.entities.get(entity);\n        if (entityComponents != null) {\n            entityComponents.set(...components);\n            for (const componentCtor of entityComponents.keys()) {\n                if (this.componentEntities.has(componentCtor)) {\n                    this.componentEntities.get(componentCtor).add(entity);\n                }\n                else {\n                    this.componentEntities.set(componentCtor, new Set([entity]));\n                }\n            }\n        }\n        return this;\n    }\n    getEntityComponents(entity) {\n        if (this.deletedEntities.has(entity)) {\n            return undefined;\n        }\n        return this.entities.get(entity);\n    }\n    removeEntityComponents(entity, ...components) {\n        if (this.deletedEntities.has(entity)) {\n            throw new Error('Entity has been deleted');\n        }\n        const entityComponents = this.entities.get(entity);\n        if (entityComponents != null) {\n            entityComponents.remove(...components.map(component => component.constructor));\n            components.forEach(component => {\n                const ctor = component.constructor;\n                if (this.componentEntities.has(ctor)) {\n                    this.componentEntities.get(ctor).delete(entity);\n                }\n            });\n        }\n        return this;\n    }\n    /**\n     * Register a system for addition. Systems are executed linearly in the order added.\n     * @param system System\n     */\n    addSystem(system) {\n        this.systemsToAdd.push(system);\n    }\n    /**\n     * Register a system for removal.\n     * @param system System\n     */\n    removeSystem(system) {\n        this.systemsToRemove.push(system);\n    }\n    updateSystems(dt) {\n        if (this.systemsToRemove.length > 0) {\n            this.systems = this.systems.filter(existing => this.systemsToRemove.includes(existing));\n            this.systemsToRemove = [];\n        }\n        if (this.systemsToAdd.length > 0) {\n            this.systemsToAdd.forEach(newSystem => {\n                if (this.systems.includes(newSystem) === false) {\n                    this.systems.push(newSystem);\n                }\n            });\n            this.systemsToAdd = [];\n        }\n        for (const system of this.systems) {\n            system.update(this, dt);\n        }\n    }\n    view(...componentCtors) {\n        const entities = new Map();\n        if (componentCtors.length === 0) {\n            return entities;\n        }\n        const componentSets = componentCtors.map(ctor => {\n            if (this.componentEntities.has(ctor) === false) {\n                throw new Error(`Component ${ctor.name} not found`);\n            }\n            return this.componentEntities.get(ctor);\n        });\n        const smallestComponentSet = componentSets.reduce((smallest, set) => {\n            if (smallest == null) {\n                smallest = set;\n            }\n            else if (set.size < smallest.size) {\n                smallest = set;\n            }\n            return smallest;\n        });\n        const otherComponentSets = componentSets.filter(set => set !== smallestComponentSet);\n        for (const entity of smallestComponentSet) {\n            const hasAll = otherComponentSets.every(set => set.has(entity));\n            if (hasAll === true) {\n                entities.set(entity, this.getEntityComponents(entity));\n            }\n        }\n        return entities;\n    }\n}\n","/*\n * A main loop useful for games and other animated applications.\n */\n(function(root) {\n\n    // The amount of time (in milliseconds) to simulate each time update()\n    // runs. See `MainLoop.setSimulationTimestep()` for details.\nvar simulationTimestep = 1000 / 60,\n\n    // The cumulative amount of in-app time that hasn't been simulated yet.\n    // See the comments inside animate() for details.\n    frameDelta = 0,\n\n    // The timestamp in milliseconds of the last time the main loop was run.\n    // Used to compute the time elapsed between frames.\n    lastFrameTimeMs = 0,\n\n    // An exponential moving average of the frames per second.\n    fps = 60,\n\n    // A factor that affects how heavily to weight more recent seconds'\n    // performance when calculating the average frames per second. Valid values\n    // range from zero to one inclusive. Higher values result in weighting more\n    // recent seconds more heavily.\n    fpsAlpha = 0.9,\n\n    // The minimum duration between updates to the frames-per-second estimate.\n    // Higher values increase accuracy, but result in slower updates.\n    fpsUpdateInterval = 1000,\n\n    // The timestamp (in milliseconds) of the last time the `fps` moving\n    // average was updated.\n    lastFpsUpdate = 0,\n\n    // The number of frames delivered since the last time the `fps` moving\n    // average was updated (i.e. since `lastFpsUpdate`).\n    framesSinceLastFpsUpdate = 0,\n\n    // The number of times update() is called in a given frame. This is only\n    // relevant inside of animate(), but a reference is held externally so that\n    // this variable is not marked for garbage collection every time the main\n    // loop runs.\n    numUpdateSteps = 0,\n\n    // The minimum amount of time in milliseconds that must pass since the last\n    // frame was executed before another frame can be executed. The\n    // multiplicative inverse caps the FPS (the default of zero means there is\n    // no cap).\n    minFrameDelay = 0,\n\n    // Whether the main loop is running.\n    running = false,\n\n    // `true` if `MainLoop.start()` has been called and the most recent time it\n    // was called has not been followed by a call to `MainLoop.stop()`. This is\n    // different than `running` because there is a delay of a few milliseconds\n    // after `MainLoop.start()` is called before the application is considered\n    // \"running.\" This delay is due to waiting for the next frame.\n    started = false,\n\n    // Whether the simulation has fallen too far behind real time.\n    // Specifically, `panic` will be set to `true` if too many updates occur in\n    // one frame. This is only relevant inside of animate(), but a reference is\n    // held externally so that this variable is not marked for garbage\n    // collection every time the main loop runs.\n    panic = false,\n\n    // The object most likely to have `requestAnimationFrame` attached is\n    // `window`, if it's available in this environment. Otherwise, fall back to\n    // the root context.\n    windowOrRoot = typeof window === 'object' ? window : root,\n\n    // The function that runs the main loop. The unprefixed version of\n    // `window.requestAnimationFrame()` is available in all modern browsers\n    // now, but node.js doesn't have it, so fall back to timers. The polyfill\n    // is adapted from the MIT-licensed\n    // https://github.com/underscorediscovery/realtime-multiplayer-in-html5\n    requestAnimationFrame = windowOrRoot.requestAnimationFrame || (function() {\n        var lastTimestamp = Date.now(),\n            now,\n            timeout;\n        return function(callback) {\n            now = Date.now();\n            // The next frame should run no sooner than the simulation allows,\n            // but as soon as possible if the current frame has already taken\n            // more time to run than is simulated in one timestep.\n            timeout = Math.max(0, simulationTimestep - (now - lastTimestamp));\n            lastTimestamp = now + timeout;\n            return setTimeout(function() {\n                callback(now + timeout);\n            }, timeout);\n        };\n    })(),\n\n    // The function that stops the main loop. The unprefixed version of\n    // `window.cancelAnimationFrame()` is available in all modern browsers now,\n    // but node.js doesn't have it, so fall back to timers.\n    cancelAnimationFrame = windowOrRoot.cancelAnimationFrame || clearTimeout,\n\n    // In all major browsers, replacing non-specified functions with NOOPs\n    // seems to be as fast or slightly faster than using conditions to only\n    // call the functions if they are specified. This is probably due to empty\n    // functions being optimized away. http://jsperf.com/noop-vs-condition\n    NOOP = function() {},\n\n    // A function that runs at the beginning of the main loop.\n    // See `MainLoop.setBegin()` for details.\n    begin = NOOP,\n\n    // A function that runs updates (i.e. AI and physics).\n    // See `MainLoop.setUpdate()` for details.\n    update = NOOP,\n\n    // A function that draws things on the screen.\n    // See `MainLoop.setDraw()` for details.\n    draw = NOOP,\n\n    // A function that runs at the end of the main loop.\n    // See `MainLoop.setEnd()` for details.\n    end = NOOP,\n\n    // The ID of the currently executing frame. Used to cancel frames when\n    // stopping the loop.\n    rafHandle;\n\n/**\n * Manages the main loop that runs updates and rendering.\n *\n * The main loop is a core part of any application in which state changes\n * even if no events are handled. In games, it is typically responsible for\n * computing physics and AI as well as drawing the result on the screen.\n *\n * The body of this particular loop is run every time the browser is ready to\n * paint another frame. The frequency with which this happens depends primarily\n * on the monitor's refresh rate, which is typically 60 frames per second. Most\n * applications aim to run at 60 FPS for this reason, meaning that the main\n * loop runs about once every 16.7 milliseconds. With this target, everything\n * that happens in the main loop (e.g. all updates and drawing) needs to occur\n * within the \"budget\" of 16.7 milliseconds.  See\n * `MainLoop.setSimulationTimestep()` for more information about typical\n * monitor refresh rates and frame rate targets.\n *\n * The main loop can be started and stopped, but there can only be one MainLoop\n * (except that each Web Worker can have its own MainLoop). There are four main\n * parts of the loop: {@link #setBegin begin}(), {@link #setUpdate update}(),\n * {@link #setDraw draw}(), and {@link #setEnd end}(), in that order. See the\n * functions that set each of them for descriptions of what they are used for.\n * Note that update() can run zero or more times per loop.\n *\n * @class MainLoop\n */\nroot.MainLoop = {\n    /**\n     * Gets how many milliseconds should be simulated by every run of update().\n     *\n     * See `MainLoop.setSimulationTimestep()` for details on this value.\n     *\n     * @return {Number}\n     *   The number of milliseconds that should be simulated by every run of\n     *   {@link #setUpdate update}().\n     */\n    getSimulationTimestep: function() {\n        return simulationTimestep;\n    },\n\n    /**\n     * Sets how many milliseconds should be simulated by every run of update().\n     *\n     * The perceived frames per second (FPS) is effectively capped at the\n     * multiplicative inverse of the simulation timestep. That is, if the\n     * timestep is 1000 / 60 (which is the default), then the maximum perceived\n     * FPS is effectively 60. Decreasing the timestep increases the maximum\n     * perceived FPS at the cost of running {@link #setUpdate update}() more\n     * times per frame at lower frame rates. Since running update() more times\n     * takes more time to process, this can actually slow down the frame rate.\n     * Additionally, if the amount of time it takes to run update() exceeds or\n     * very nearly exceeds the timestep, the application will freeze and crash\n     * in a spiral of death (unless it is rescued; see `MainLoop.setEnd()` for\n     * an explanation of what can be done if a spiral of death is occurring).\n     *\n     * The exception to this is that interpolating between updates for each\n     * render can increase the perceived frame rate and reduce visual\n     * stuttering. See `MainLoop.setDraw()` for an explanation of how to do\n     * this.\n     *\n     * If you are considering decreasing the simulation timestep in order to\n     * raise the maximum perceived FPS, keep in mind that most monitors can't\n     * display more than 60 FPS. Whether humans can tell the difference among\n     * high frame rates depends on the application, but for reference, film is\n     * usually displayed at 24 FPS, other videos at 30 FPS, most games are\n     * acceptable above 30 FPS, and virtual reality might require 75 FPS to\n     * feel natural. Some gaming monitors go up to 144 FPS. Setting the\n     * timestep below 1000 / 144 is discouraged and below 1000 / 240 is\n     * strongly discouraged. The default of 1000 / 60 is good in most cases.\n     *\n     * The simulation timestep should typically only be changed at\n     * deterministic times (e.g. before the main loop starts for the first\n     * time, and not in response to user input or slow frame rates) to avoid\n     * introducing non-deterministic behavior. The update timestep should be\n     * the same for all players/users in multiplayer/multi-user applications.\n     *\n     * See also `MainLoop.getSimulationTimestep()`.\n     *\n     * @param {Number} timestep\n     *   The number of milliseconds that should be simulated by every run of\n     *   {@link #setUpdate update}().\n     */\n    setSimulationTimestep: function(timestep) {\n        simulationTimestep = timestep;\n        return this;\n    },\n\n    /**\n     * Returns the exponential moving average of the frames per second.\n     *\n     * @return {Number}\n     *   The exponential moving average of the frames per second.\n     */\n    getFPS: function() {\n        return fps;\n    },\n\n    /**\n     * Gets the maximum frame rate.\n     *\n     * Other factors also limit the FPS; see `MainLoop.setSimulationTimestep`\n     * for details.\n     *\n     * See also `MainLoop.setMaxAllowedFPS()`.\n     *\n     * @return {Number}\n     *   The maximum number of frames per second allowed.\n     */\n    getMaxAllowedFPS: function() {\n        return 1000 / minFrameDelay;\n    },\n\n    /**\n     * Sets a maximum frame rate.\n     *\n     * See also `MainLoop.getMaxAllowedFPS()`.\n     *\n     * @param {Number} [fps=Infinity]\n     *   The maximum number of frames per second to execute. If Infinity or not\n     *   passed, there will be no FPS cap (although other factors do limit the\n     *   FPS; see `MainLoop.setSimulationTimestep` for details). If zero, this\n     *   will stop the loop, and when the loop is next started, it will return\n     *   to the previous maximum frame rate. Passing negative values will stall\n     *   the loop until this function is called again with a positive value.\n     *\n     * @chainable\n     */\n    setMaxAllowedFPS: function(fps) {\n        if (typeof fps === 'undefined') {\n            fps = Infinity;\n        }\n        if (fps === 0) {\n            this.stop();\n        }\n        else {\n            // Dividing by Infinity returns zero.\n            minFrameDelay = 1000 / fps;\n        }\n        return this;\n    },\n\n    /**\n     * Reset the amount of time that has not yet been simulated to zero.\n     *\n     * This introduces non-deterministic behavior if called after the\n     * application has started running (unless it is being reset, in which case\n     * it doesn't matter). However, this can be useful in cases where the\n     * amount of time that has not yet been simulated has grown very large\n     * (for example, when the application's tab gets put in the background and\n     * the browser throttles the timers as a result). In applications with\n     * lockstep the player would get dropped, but in other networked\n     * applications it may be necessary to snap or ease the player/user to the\n     * authoritative state and discard pending updates in the process. In\n     * non-networked applications it may also be acceptable to simply resume\n     * the application where it last left off and ignore the accumulated\n     * unsimulated time.\n     *\n     * @return {Number}\n     *   The cumulative amount of elapsed time in milliseconds that has not yet\n     *   been simulated, but is being discarded as a result of calling this\n     *   function.\n     */\n    resetFrameDelta: function() {\n        var oldFrameDelta = frameDelta;\n        frameDelta = 0;\n        return oldFrameDelta;\n    },\n\n    /**\n     * Sets the function that runs at the beginning of the main loop.\n     *\n     * The begin() function is typically used to process input before the\n     * updates run. Processing input here (in chunks) can reduce the running\n     * time of event handlers, which is useful because long-running event\n     * handlers can sometimes delay frames.\n     *\n     * Unlike {@link #setUpdate update}(), which can run zero or more times per\n     * frame, begin() always runs exactly once per frame. This makes it useful\n     * for any updates that are not dependent on time in the simulation.\n     * Examples include adjusting HUD calculations or performing long-running\n     * updates incrementally. Compared to {@link #setEnd end}(), generally\n     * actions should occur in begin() if they affect anything that\n     * {@link #setUpdate update}() or {@link #setDraw draw}() use.\n     *\n     * @param {Function} begin\n     *   The begin() function.\n     * @param {Number} [begin.timestamp]\n     *   The current timestamp (when the frame started), in milliseconds. This\n     *   should only be used for comparison to other timestamps because the\n     *   epoch (i.e. the \"zero\" time) depends on the engine running this code.\n     *   In engines that support `DOMHighResTimeStamp` (all modern browsers\n     *   except iOS Safari 8) the epoch is the time the page started loading,\n     *   specifically `performance.timing.navigationStart`. Everywhere else,\n     *   including node.js, the epoch is the Unix epoch (1970-01-01T00:00:00Z).\n     * @param {Number} [begin.delta]\n     *   The total elapsed time that has not yet been simulated, in\n     *   milliseconds.\n     */\n    setBegin: function(fun) {\n        begin = fun || begin;\n        return this;\n    },\n\n    /**\n     * Sets the function that runs updates (e.g. AI and physics).\n     *\n     * The update() function should simulate anything that is affected by time.\n     * It can be called zero or more times per frame depending on the frame\n     * rate.\n     *\n     * As with everything in the main loop, the running time of update()\n     * directly affects the frame rate. If update() takes long enough that the\n     * frame rate drops below the target (\"budgeted\") frame rate, parts of the\n     * update() function that do not need to execute between every frame can be\n     * moved into Web Workers. (Various sources on the internet sometimes\n     * suggest other scheduling patterns using setTimeout() or setInterval().\n     * These approaches sometimes offer modest improvements with minimal\n     * changes to existing code, but because JavaScript is single-threaded, the\n     * updates will still block rendering and drag down the frame rate. Web\n     * Workers execute in separate threads, so they free up more time in the\n     * main loop.)\n     *\n     * This script can be imported into a Web Worker using importScripts() and\n     * used to run a second main loop in the worker. Some considerations:\n     *\n     * - Profile your code before doing the work to move it into Web Workers.\n     *   It could be the rendering that is the bottleneck, in which case the\n     *   solution is to decrease the visual complexity of the scene.\n     * - It doesn't make sense to move the *entire* contents of update() into\n     *   workers unless {@link #setDraw draw}() can interpolate between frames.\n     *   The lowest-hanging fruit is background updates (like calculating\n     *   citizens' happiness in a city-building game), physics that doesn't\n     *   affect the scene (like flags waving in the wind), and anything that is\n     *   occluded or happening far off screen.\n     * - If draw() needs to interpolate physics based on activity that occurs\n     *   in a worker, the worker needs to pass the interpolation value back to\n     *   the main thread so that is is available to draw().\n     * - Web Workers can't access the state of the main thread, so they can't\n     *   directly modify objects in your scene. Moving data to and from Web\n     *   Workers is a pain. The fastest way to do it is with Transferable\n     *   Objects: basically, you can pass an ArrayBuffer to a worker,\n     *   destroying the original reference in the process.\n     *\n     * You can read more about Web Workers and Transferable Objects at\n     * [HTML5 Rocks](http://www.html5rocks.com/en/tutorials/workers/basics/).\n     *\n     * @param {Function} update\n     *   The update() function.\n     * @param {Number} [update.delta]\n     *   The amount of time in milliseconds to simulate in the update. In most\n     *   cases this timestep never changes in order to ensure deterministic\n     *   updates. The timestep is the same as that returned by\n     *   `MainLoop.getSimulationTimestep()`.\n     */\n    setUpdate: function(fun) {\n        update = fun || update;\n        return this;\n    },\n\n    /**\n     * Sets the function that draws things on the screen.\n     *\n     * The draw() function gets passed the percent of time that the next run of\n     * {@link #setUpdate update}() will simulate that has actually elapsed, as\n     * a decimal. In other words, draw() gets passed how far between update()\n     * calls it is. This is useful because the time simulated by update() and\n     * the time between draw() calls is usually different, so the parameter to\n     * draw() can be used to interpolate motion between frames to make\n     * rendering appear smoother. To illustrate, if update() advances the\n     * simulation at each vertical bar in the first row below, and draw() calls\n     * happen at each vertical bar in the second row below, then some frames\n     * will have time left over that is not yet simulated by update() when\n     * rendering occurs in draw():\n     *\n     *     update() timesteps:  |  |  |  |  |  |  |  |  |\n     *     draw() calls:        |   |   |   |   |   |   |\n     *\n     * To interpolate motion for rendering purposes, objects' state after the\n     * last update() must be retained and used to calculate an intermediate\n     * state. Note that this means renders will be up to one update() behind.\n     * This is still better than extrapolating (projecting objects' state after\n     * a future update()) which can produce bizarre results. Storing multiple\n     * states can be difficult to set up, and keep in mind that running this\n     * process takes time that could push the frame rate down, so it's often\n     * not worthwhile unless stuttering is visible.\n     *\n     * @param {Function} draw\n     *   The draw() function.\n     * @param {Number} [draw.interpolationPercentage]\n     *   The cumulative amount of time that hasn't been simulated yet, divided\n     *   by the amount of time that will be simulated the next time update()\n     *   runs. Useful for interpolating frames.\n     */\n    setDraw: function(fun) {\n        draw = fun || draw;\n        return this;\n    },\n\n    /**\n     * Sets the function that runs at the end of the main loop.\n     *\n     * Unlike {@link #setUpdate update}(), which can run zero or more times per\n     * frame, end() always runs exactly once per frame. This makes it useful\n     * for any updates that are not dependent on time in the simulation.\n     * Examples include cleaning up any temporary state set up by\n     * {@link #setBegin begin}(), lowering the visual quality if the frame rate\n     * is too low, or performing long-running updates incrementally. Compared\n     * to begin(), generally actions should occur in end() if they use anything\n     * that update() or {@link #setDraw draw}() affect.\n     *\n     * @param {Function} end\n     *   The end() function.\n     * @param {Number} [end.fps]\n     *   The exponential moving average of the frames per second. This is the\n     *   same value returned by `MainLoop.getFPS()`. It can be used to take\n     *   action when the FPS is too low (or to restore to normalcy if the FPS\n     *   moves back up). Examples of actions to take if the FPS is too low\n     *   include exiting the application, lowering the visual quality, stopping\n     *   or reducing activities outside of the main loop like event handlers or\n     *   audio playback, performing non-critical updates less frequently, or\n     *   increasing the simulation timestep (by calling\n     *   `MainLoop.setSimulationTimestep()`). Note that this last option\n     *   results in more time being simulated per update() call, which causes\n     *   the application to behave non-deterministically.\n     * @param {Boolean} [end.panic=false]\n     *   Indicates whether the simulation has fallen too far behind real time.\n     *   Specifically, `panic` will be `true` if too many updates occurred in\n     *   one frame. In networked lockstep applications, the application should\n     *   wait for some amount of time to see if the user can catch up before\n     *   dropping the user. In networked but non-lockstep applications, this\n     *   typically indicates that the user needs to be snapped or eased to the\n     *   current authoritative state. When this happens, it may be convenient\n     *   to call `MainLoop.resetFrameDelta()` to discard accumulated pending\n     *   updates. In non-networked applications, it may be acceptable to allow\n     *   the application to keep running for awhile to see if it will catch up.\n     *   However, this could also cause the application to look like it is\n     *   running very quickly for a few frames as it transitions through the\n     *   intermediate states. An alternative that may be acceptable is to\n     *   simply ignore the unsimulated elapsed time by calling\n     *   `MainLoop.resetFrameDelta()` even though this introduces\n     *   non-deterministic behavior. In all cases, if the application panics\n     *   frequently, this is an indication that the main loop is running too\n     *   slowly. However, most of the time the drop in frame rate will probably\n     *   be noticeable before a panic occurs. To help the application catch up\n     *   after a panic caused by a spiral of death, the same steps can be taken\n     *   that are suggested above if the FPS drops too low.\n     */\n    setEnd: function(fun) {\n        end = fun || end;\n        return this;\n    },\n\n    /**\n     * Starts the main loop.\n     *\n     * Note that the application is not considered \"running\" immediately after\n     * this function returns; rather, it is considered \"running\" after the\n     * application draws its first frame. The distinction is that event\n     * handlers should remain paused until the application is running, even\n     * after `MainLoop.start()` is called. Check `MainLoop.isRunning()` for the\n     * current status. To act after the application starts, register a callback\n     * with requestAnimationFrame() after calling this function and execute the\n     * action in that callback. It is safe to call `MainLoop.start()` multiple\n     * times even before the application starts running and without calling\n     * `MainLoop.stop()` in between, although there is no reason to do this;\n     * the main loop will only start if it is not already started.\n     *\n     * See also `MainLoop.stop()`.\n     */\n    start: function() {\n        if (!started) {\n            // Since the application doesn't start running immediately, track\n            // whether this function was called and use that to keep it from\n            // starting the main loop multiple times.\n            started = true;\n\n            // In the main loop, draw() is called after update(), so if we\n            // entered the main loop immediately, we would never render the\n            // initial state before any updates occur. Instead, we run one\n            // frame where all we do is draw, and then start the main loop with\n            // the next frame.\n            rafHandle = requestAnimationFrame(function(timestamp) {\n                // Render the initial state before any updates occur.\n                draw(1);\n\n                // The application isn't considered \"running\" until the\n                // application starts drawing.\n                running = true;\n\n                // Reset variables that are used for tracking time so that we\n                // don't simulate time passed while the application was paused.\n                lastFrameTimeMs = timestamp;\n                lastFpsUpdate = timestamp;\n                framesSinceLastFpsUpdate = 0;\n\n                // Start the main loop.\n                rafHandle = requestAnimationFrame(animate);\n            });\n        }\n        return this;\n    },\n\n    /**\n     * Stops the main loop.\n     *\n     * Event handling and other background tasks should also be paused when the\n     * main loop is paused.\n     *\n     * Note that pausing in multiplayer/multi-user applications will cause the\n     * player's/user's client to become out of sync. In this case the\n     * simulation should exit, or the player/user needs to be snapped to their\n     * updated position when the main loop is started again.\n     *\n     * See also `MainLoop.start()` and `MainLoop.isRunning()`.\n     */\n    stop: function() {\n        running = false;\n        started = false;\n        cancelAnimationFrame(rafHandle);\n        return this;\n    },\n\n    /**\n     * Returns whether the main loop is currently running.\n     *\n     * See also `MainLoop.start()` and `MainLoop.stop()`.\n     *\n     * @return {Boolean}\n     *   Whether the main loop is currently running.\n     */\n    isRunning: function() {\n        return running;\n    },\n};\n\n/**\n * The main loop that runs updates and rendering.\n *\n * @param {DOMHighResTimeStamp} timestamp\n *   The current timestamp. In practice this is supplied by\n *   requestAnimationFrame at the time that it starts to fire callbacks. This\n *   should only be used for comparison to other timestamps because the epoch\n *   (i.e. the \"zero\" time) depends on the engine running this code. In engines\n *   that support `DOMHighResTimeStamp` (all modern browsers except iOS Safari\n *   8) the epoch is the time the page started loading, specifically\n *   `performance.timing.navigationStart`. Everywhere else, including node.js,\n *   the epoch is the Unix epoch (1970-01-01T00:00:00Z).\n *\n * @ignore\n */\nfunction animate(timestamp) {\n    // Run the loop again the next time the browser is ready to render.\n    // We set rafHandle immediately so that the next frame can be canceled\n    // during the current frame.\n    rafHandle = requestAnimationFrame(animate);\n\n    // Throttle the frame rate (if minFrameDelay is set to a non-zero value by\n    // `MainLoop.setMaxAllowedFPS()`).\n    if (timestamp < lastFrameTimeMs + minFrameDelay) {\n        return;\n    }\n\n    // frameDelta is the cumulative amount of in-app time that hasn't been\n    // simulated yet. Add the time since the last frame. We need to track total\n    // not-yet-simulated time (as opposed to just the time elapsed since the\n    // last frame) because not all actually elapsed time is guaranteed to be\n    // simulated each frame. See the comments below for details.\n    frameDelta += timestamp - lastFrameTimeMs;\n    lastFrameTimeMs = timestamp;\n\n    // Run any updates that are not dependent on time in the simulation. See\n    // `MainLoop.setBegin()` for additional details on how to use this.\n    begin(timestamp, frameDelta);\n\n    // Update the estimate of the frame rate, `fps`. Approximately every\n    // second, the number of frames that occurred in that second are included\n    // in an exponential moving average of all frames per second. This means\n    // that more recent seconds affect the estimated frame rate more than older\n    // seconds.\n    if (timestamp > lastFpsUpdate + fpsUpdateInterval) {\n        // Compute the new exponential moving average.\n        fps =\n            // Divide the number of frames since the last FPS update by the\n            // amount of time that has passed to get the mean frames per second\n            // over that period. This is necessary because slightly more than a\n            // second has likely passed since the last update.\n            fpsAlpha * framesSinceLastFpsUpdate * 1000 / (timestamp - lastFpsUpdate) +\n            (1 - fpsAlpha) * fps;\n\n        // Reset the frame counter and last-updated timestamp since their\n        // latest values have now been incorporated into the FPS estimate.\n        lastFpsUpdate = timestamp;\n        framesSinceLastFpsUpdate = 0;\n    }\n    // Count the current frame in the next frames-per-second update. This\n    // happens after the previous section because the previous section\n    // calculates the frames that occur up until `timestamp`, and `timestamp`\n    // refers to a time just before the current frame was delivered.\n    framesSinceLastFpsUpdate++;\n\n    /*\n     * A naive way to move an object along its X-axis might be to write a main\n     * loop containing the statement `obj.x += 10;` which would move the object\n     * 10 units per frame. This approach suffers from the issue that it is\n     * dependent on the frame rate. In other words, if your application is\n     * running slowly (that is, fewer frames per second), your object will also\n     * appear to move slowly, whereas if your application is running quickly\n     * (that is, more frames per second), your object will appear to move\n     * quickly. This is undesirable, especially in multiplayer/multi-user\n     * applications.\n     *\n     * One solution is to multiply the speed by the amount of time that has\n     * passed between rendering frames. For example, if you want your object to\n     * move 600 units per second, you might write `obj.x += 600 * delta`, where\n     * `delta` is the time passed since the last frame. (For convenience, let's\n     * move this statement to an update() function that takes `delta` as a\n     * parameter.) This way, your object will move a constant distance over\n     * time. However, at low frame rates and high speeds, your object will move\n     * large distances every frame, which can cause it to do strange things\n     * such as move through walls. Additionally, we would like our program to\n     * be deterministic. That is, every time we run the application with the\n     * same input, we would like exactly the same output. If the time between\n     * frames (the `delta`) varies, our output will diverge the longer the\n     * program runs due to accumulated rounding errors, even at normal frame\n     * rates.\n     *\n     * A better solution is to separate the amount of time simulated in each\n     * update() from the amount of time between frames. Our update() function\n     * doesn't need to change; we just need to change the delta we pass to it\n     * so that each update() simulates a fixed amount of time (that is, `delta`\n     * should have the same value each time update() is called). The update()\n     * function can be run multiple times per frame if needed to simulate the\n     * total amount of time passed since the last frame. (If the time that has\n     * passed since the last frame is less than the fixed simulation time, we\n     * just won't run an update() until the the next frame. If there is\n     * unsimulated time left over that is less than our timestep, we'll just\n     * leave it to be simulated during the next frame.) This approach avoids\n     * inconsistent rounding errors and ensures that there are no giant leaps\n     * through walls between frames.\n     *\n     * That is what is done below. It introduces a new problem, but it is a\n     * manageable one: if the amount of time spent simulating is consistently\n     * longer than the amount of time between frames, the application could\n     * freeze and crash in a spiral of death. This won't happen as long as the\n     * fixed simulation time is set to a value that is high enough that\n     * update() calls usually take less time than the amount of time they're\n     * simulating. If it does start to happen anyway, see `MainLoop.setEnd()`\n     * for a discussion of ways to stop it.\n     *\n     * Additionally, see `MainLoop.setUpdate()` for a discussion of performance\n     * considerations.\n     *\n     * Further reading for those interested:\n     *\n     * - http://gameprogrammingpatterns.com/game-loop.html\n     * - http://gafferongames.com/game-physics/fix-your-timestep/\n     * - https://gamealchemist.wordpress.com/2013/03/16/thoughts-on-the-javascript-game-loop/\n     * - https://developer.mozilla.org/en-US/docs/Games/Anatomy\n     */\n    numUpdateSteps = 0;\n    while (frameDelta >= simulationTimestep) {\n        update(simulationTimestep);\n        frameDelta -= simulationTimestep;\n\n        /*\n         * Sanity check: bail if we run the loop too many times.\n         *\n         * One way this could happen is if update() takes longer to run than\n         * the time it simulates, thereby causing a spiral of death. For ways\n         * to avoid this, see `MainLoop.setEnd()`. Another way this could\n         * happen is if the browser throttles serving frames, which typically\n         * occurs when the tab is in the background or the device battery is\n         * low. An event outside of the main loop such as audio processing or\n         * synchronous resource reads could also cause the application to hang\n         * temporarily and accumulate not-yet-simulated time as a result.\n         *\n         * 240 is chosen because, for any sane value of simulationTimestep, 240\n         * updates will simulate at least one second, and it will simulate four\n         * seconds with the default value of simulationTimestep. (Safari\n         * notifies users that the script is taking too long to run if it takes\n         * more than five seconds.)\n         *\n         * If there are more updates to run in a frame than this, the\n         * application will appear to slow down to the user until it catches\n         * back up. In networked applications this will usually cause the user\n         * to get out of sync with their peers, but if the updates are taking\n         * this long already, they're probably already out of sync.\n         */\n        if (++numUpdateSteps >= 240) {\n            panic = true;\n            break;\n        }\n    }\n\n    /*\n     * Render the screen. We do this regardless of whether update() has run\n     * during this frame because it is possible to interpolate between updates\n     * to make the frame rate appear faster than updates are actually\n     * happening. See `MainLoop.setDraw()` for an explanation of how to do\n     * that.\n     *\n     * We draw after updating because we want the screen to reflect a state of\n     * the application that is as up-to-date as possible. (`MainLoop.start()`\n     * draws the very first frame in the application's initial state, before\n     * any updates have occurred.) Some sources speculate that rendering\n     * earlier in the requestAnimationFrame callback can get the screen painted\n     * faster; this is mostly not true, and even when it is, it's usually just\n     * a trade-off between rendering the current frame sooner and rendering the\n     * next frame later.\n     *\n     * See `MainLoop.setDraw()` for details about draw() itself.\n     */\n    draw(frameDelta / simulationTimestep);\n\n    // Run any updates that are not dependent on time in the simulation. See\n    // `MainLoop.setEnd()` for additional details on how to use this.\n    end(fps, panic);\n\n    panic = false;\n}\n\n// AMD support\nif (typeof define === 'function' && define.amd) {\n    define(root.MainLoop);\n}\n// CommonJS support\nelse if (typeof module === 'object' && module !== null && typeof module.exports === 'object') {\n    module.exports = root.MainLoop;\n}\n\n})(this);\n","import { Component } from \"@jakeklassen/ecs\";\n\nexport class Color extends Component {\n  constructor(public color: string) {\n    super();\n  }\n}\n\n","import { Component } from \"@jakeklassen/ecs\";\n\nexport class Rectangle extends Component {\n  constructor(\n    public readonly x: number,\n    public readonly y: number,\n    public readonly width: number,\n    public readonly height: number,\n  ) {\n    super();\n  }\n}\n","import { Component } from \"@jakeklassen/ecs\";\n\nexport class Vector2 extends Component {\n  public static zero() {\n    return new Vector2(0, 0);\n  }\n\n  public x = 0;\n  public y = 0;\n\n  constructor(x = 0, y = 0) {\n    super();\n\n    this.x = x;\n    this.y = y;\n  }\n}\n","import { Component } from '@jakeklassen/ecs';\nimport { Vector2 } from '../vector2';\n\nexport class Transform extends Component {\n  public position = Vector2.zero();\n\n  constructor(position: Vector2 = Vector2.zero()) {\n    super();\n\n    this.position = position;\n  }\n}\n","import { Component } from \"@jakeklassen/ecs\";\n\nexport class Velocity extends Component {\n  constructor(public x = 0, public y = 0) {\n    super();\n  }\n\n  public flipX() {\n    this.x *= -1;\n  }\n\n  public flipY() {\n    this.y *= -1;\n  }\n}\n","export * from './color';\nexport * from './rectangle';\nexport * from './transform';\nexport * from './velocity';\n","import { Component } from '@jakeklassen/ecs';\n\nexport class BallTag extends Component {}\n","// tslint:disable: max-classes-per-file\n\nimport { System, World } from '@jakeklassen/ecs';\nimport * as mainloop from 'mainloop.js';\nimport { Color, Rectangle, Transform, Velocity } from '../shared/components';\nimport { Vector2 } from '../shared/vector2';\nimport { BallTag } from './components/ball-tag';\n\nconst canvas = document.querySelector('#canvas') as HTMLCanvasElement;\nconst ctx = canvas.getContext('2d');\n\nif (ctx == null) {\n  throw new Error('failed to obtain canvas 2d context');\n}\n\nconst world = new World();\nconst ball = world.createEntity();\n\nworld.addEntityComponents(\n  ball,\n  new BallTag(),\n  new Transform(new Vector2(10, 10)),\n  new Velocity(100, 200),\n  new Rectangle(10, 10, 12, 12),\n  new Color('red'),\n);\n\nclass BallMovementSystem extends System {\n  constructor(private readonly viewport: Rectangle) {\n    super();\n  }\n\n  public update(world: World, dt: number) {\n    const ball = world.findEntity(BallTag);\n\n    if (ball == null) {\n      throw new Error('Entity with BallTag not found');\n    }\n\n    const components = world.getEntityComponents(ball)!;\n\n    const rectangle = components.get<Rectangle>(Rectangle)!;\n    const transform = components.get<Transform>(Transform)!;\n    const velocity = components.get<Velocity>(Velocity)!;\n\n    transform.position.x += velocity.x * dt;\n    transform.position.y += velocity.y * dt;\n\n    if (transform.position.x + rectangle.width > this.viewport.width) {\n      transform.position.x = this.viewport.width - rectangle.width;\n      velocity.flipX();\n    } else if (transform.position.x < 0) {\n      transform.position.x = 0;\n      velocity.flipX();\n    }\n\n    if (transform.position.y + rectangle.height > this.viewport.height) {\n      transform.position.y = this.viewport.height - rectangle.height;\n      velocity.flipY();\n    } else if (transform.position.y < 0) {\n      transform.position.y = 0;\n      velocity.flipY();\n    }\n  }\n}\n\nclass RenderingSystem extends System {\n  constructor(private readonly context: CanvasRenderingContext2D) {\n    super();\n  }\n\n  public update(world: World) {\n    this.context.clearRect(0, 0, 640, 480);\n\n    for (const [entity, components] of world.view(\n      Rectangle,\n      Color,\n      Transform,\n    )) {\n      const { color } = components.get(Color) as Color;\n      const { width, height } = components.get(Rectangle) as Rectangle;\n      const transform = components.get(Transform) as Transform;\n\n      this.context.fillStyle = color;\n      this.context.fillRect(\n        transform.position.x,\n        transform.position.y,\n        width,\n        height,\n      );\n    }\n  }\n}\n\nworld.addSystem(\n  new BallMovementSystem(new Rectangle(0, 0, canvas.width, canvas.height)),\n);\nworld.addSystem(new RenderingSystem(ctx));\n\nmainloop\n  .setUpdate((dt: number) => {\n    world.updateSystems(dt / 1000);\n  })\n  .start();\n"]}