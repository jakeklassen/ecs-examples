{"version":3,"sources":["../dist-src/entity.js","../dist-src/system.js","../dist-src/bitset.js","../dist-src/component-map.js","../dist-src/world.js","../dist-src/component.js","../src/mainloop.js","shared/components/color.ts","shared/components/rectangle.ts","shared/vector2.ts","shared/components/transform.ts","shared/components/velocity.ts","shared/components/index.ts","basic/components/ball-tag.ts","basic/basic.ts","node_modules/parcel-bundler/src/builtins/hmr-runtime.js"],"names":["root","animate","timestamp","rafHandle","requestAnimationFrame","lastFrameTimeMs","minFrameDelay","frameDelta","begin","lastFpsUpdate","fpsUpdateInterval","fps","fpsAlpha","framesSinceLastFpsUpdate","numUpdateSteps","simulationTimestep","update","panic","draw","end","running","started","windowOrRoot","window","lastTimestamp","Date","now","timeout","callback","Math","max","setTimeout","cancelAnimationFrame","clearTimeout","NOOP","MainLoop","getSimulationTimestep","setSimulationTimestep","timestep","this","getFPS","getMaxAllowedFPS","setMaxAllowedFPS","Infinity","stop","resetFrameDelta","oldFrameDelta","setBegin","fun","setUpdate","setDraw","setEnd","start","isRunning","define","amd","module","exports","OVERLAY_ID","OldModule","bundle","Module","moduleName","call","hot","data","hotData","_acceptCallbacks","_disposeCallbacks","accept","fn","push","dispose","checkedAssets","assetsToAccept","parent","isParcelRequire","WebSocket","hostname","location","protocol","ws","onmessage","event","JSON","parse","type","handled","assets","forEach","asset","isNew","didAccept","hmrAcceptCheck","global","parcelRequire","id","every","generated","js","console","clear","hmrApply","v","hmrAcceptRun","reload","close","onclose","log","removeErrorOverlay","error","message","stack","overlay","createErrorOverlay","document","body","appendChild","getElementById","remove","createElement","stackTrace","innerText","innerHTML","getParents","modules","parents","k","d","dep","Array","isArray","length","concat","Function","deps","cached","cache","some","cb"],"mappings":"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","file":"basic.b21408c9.js","sourceRoot":"..","sourcesContent":["/**\n * Representation of a unique entity value within the world\n */\nexport class Entity {\n    constructor(id) {\n        this.id = id;\n        this.version = 0;\n    }\n}\n","/**\n * Class for all Systems to derive from\n */\nexport class System {\n}\n","// Matt Krick, matt.krick@gmail.com, MIT License\n// each bin holds bits 0 - 30, totaling 31 (sign takes up last bit)\nexport const BITS_PER_INT = 31;\n// used for ffs of a word in O(1) time. LUTs get a bad wrap, they are fast.\nexport const multiplyDeBruijnBitPosition = [\n    0,\n    1,\n    28,\n    2,\n    29,\n    14,\n    24,\n    3,\n    30,\n    22,\n    20,\n    15,\n    25,\n    17,\n    4,\n    8,\n    31,\n    27,\n    13,\n    23,\n    21,\n    19,\n    16,\n    7,\n    26,\n    12,\n    18,\n    6,\n    11,\n    5,\n    10,\n    9,\n];\nexport class BitSet {\n    /**\n     * Create a new bitset. Accepts either the maximum number of bits, or a dehydrated bitset\n     * @param {number|string} nBitsOrKey - Number of bits in the set or dehydrated bitset.\n     * For speed and space concerns, the initial number of bits cannot be increased.\n     * @constructor\n     */\n    constructor(nBitsOrKey) {\n        this.MAX_BIT = 0;\n        let wordCount;\n        let arrVals;\n        let front;\n        let leadingZeros;\n        let i;\n        if (typeof nBitsOrKey === 'number') {\n            nBitsOrKey = nBitsOrKey || BITS_PER_INT; // default to 1 word\n            wordCount = Math.ceil(nBitsOrKey / BITS_PER_INT);\n            this.arr = new Uint32Array(wordCount);\n            this.MAX_BIT = nBitsOrKey - 1;\n        }\n        else {\n            arrVals = JSON.parse('[' + nBitsOrKey + ']');\n            this.MAX_BIT = arrVals.pop();\n            leadingZeros = arrVals.pop();\n            if (leadingZeros > 0) {\n                front = [];\n                for (i = 0; i < leadingZeros; i++) {\n                    front[i] = 0;\n                }\n                for (i = 0; i < arrVals.length; i++) {\n                    front[leadingZeros + i] = arrVals[i];\n                }\n                arrVals = front;\n            }\n            wordCount = Math.ceil((this.MAX_BIT + 1) / BITS_PER_INT);\n            this.arr = new Uint32Array(wordCount);\n            this.arr.set(arrVals);\n        }\n    }\n    /**\n     * Check whether a bit at a specific index is set\n     * @param {number} idx the position of a single bit to check\n     * @returns {boolean} true if bit is set, else false\n     */\n    get(idx) {\n        const word = this.getWord(idx);\n        return word === -1\n            ? false\n            : ((this.arr[word] >> idx % BITS_PER_INT) & 1) === 1;\n    }\n    /**\n     * Set a single bit\n     * @param {number} idx the position of a single bit to set\n     * @returns {boolean} true if set was successful, else false\n     */\n    set(idx) {\n        const word = this.getWord(idx);\n        if (word === -1) {\n            return false;\n        }\n        this.arr[word] |= 1 << idx % BITS_PER_INT;\n        return true;\n    }\n    /**\n     * Set a range of bits\n     * @param {number} from the starting index of the range to set\n     * @param {number} to the ending index of the range to set\n     * @returns {boolean} true if set was successful, else false\n     */\n    setRange(from, to) {\n        return this.doRange(from, to, setFunc);\n    }\n    /**\n     * Unset a single bit\n     * @param {number} idx the position of a single bit to unset\n     * @returns {boolean} true if set was successful, else false\n     */\n    unset(idx) {\n        const word = this.getWord(idx);\n        if (word === -1) {\n            return false;\n        }\n        this.arr[word] &= ~(1 << idx % BITS_PER_INT);\n        return true;\n    }\n    /**\n     * Toggle a single bit\n     * @param {number} idx the position of a single bit to toggle\n     * @returns {boolean} true if set was successful, else false\n     */\n    toggle(idx) {\n        const word = this.getWord(idx);\n        if (word === -1) {\n            return false;\n        }\n        this.arr[word] ^= 1 << idx % BITS_PER_INT;\n        return true;\n    }\n    /**\n     * Toggle a range of bits\n     * @param {number} from the starting index of the range to toggle\n     * @param {number} to the ending index of the range to toggle\n     * @returns {boolean} true if set was successful, else false\n     */\n    toggleRange(from, to) {\n        return this.doRange(from, to, toggleFunc);\n    }\n    /**\n     *\n     * Clear an entire bitset\n     * @returns {boolean} true\n     */\n    clear() {\n        for (let i = 0; i < this.arr.length; i++) {\n            this.arr[i] = 0;\n        }\n        return true;\n    }\n    /**\n     * Clone a bitset\n     * @returns {BitSet} an copy (by value) of the calling bitset\n     */\n    clone() {\n        return new BitSet(this.dehydrate());\n    }\n    /**\n     *\n     * Turn the bitset into a comma separated string that skips leading & trailing 0 words.\n     * Ends with the number of leading 0s and MAX_BIT.\n     * Useful if you need the bitset to be an object key (eg dynamic programming).\n     * Can rehydrate by passing the result into the constructor\n     * @returns {string} representation of the bitset\n     */\n    dehydrate() {\n        let i;\n        let lastUsedWord = 0;\n        let s;\n        let leadingZeros = 0;\n        for (i = 0; i < this.arr.length; i++) {\n            if (this.arr[i] !== 0) {\n                break;\n            }\n            leadingZeros++;\n        }\n        for (i = this.arr.length - 1; i >= leadingZeros; i--) {\n            if (this.arr[i] !== 0) {\n                lastUsedWord = i;\n                break;\n            }\n        }\n        s = '';\n        for (i = leadingZeros; i <= lastUsedWord; i++) {\n            s += this.arr[i] + ',';\n        }\n        s += leadingZeros + ',' + this.MAX_BIT; // leading 0s, stop numbers\n        return s;\n    }\n    /**\n     *\n     * Perform a bitwise AND on 2 bitsets or 1 bitset and 1 index.\n     * Both bitsets must have the same number of words, no length check is performed to prevent and overflow.\n     * @param {BitSet | Number} bsOrIdx a bitset or single index to check (useful for LP, DP problems)\n     * @returns {BitSet} a new bitset that is the bitwise AND of the two\n     */\n    and(bsOrIdx) {\n        return this.op(bsOrIdx, and);\n    }\n    /**\n     *\n     * Perform a bitwise OR on 2 bitsets or 1 bitset and 1 index.\n     * Both bitsets must have the same number of words, no length check is performed to prevent and overflow.\n     * @param {BitSet | Number} bsOrIdx a bitset or single index to check (useful for LP, DP problems)\n     * @returns {BitSet} a new bitset that is the bitwise OR of the two\n     */\n    or(bsOrIdx) {\n        return this.op(bsOrIdx, or);\n    }\n    /**\n     *\n     * Perform a bitwise XOR on 2 bitsets or 1 bitset and 1 index.\n     * Both bitsets must have the same number of words, no length check is performed to prevent and overflow.\n     * @param {BitSet | Number} bsOrIdx a bitset or single index to check (useful for LP, DP problems)\n     * @returns {BitSet} a new bitset that is the bitwise XOR of the two\n     */\n    xor(bsOrIdx) {\n        return this.op(bsOrIdx, xor);\n    }\n    /**\n     * Run a custom function on every set bit. Faster than iterating over the entire bitset with a `get()`\n     * Source code includes a nice pattern to follow if you need to break the for-loop early\n     * @param {Function} func the function to pass the next set bit to\n     */\n    // tslint:disable-next-line: ban-types\n    forEach(func) {\n        for (let i = this.ffs(); i !== -1; i = this.nextSetBit(i + 1)) {\n            func(i);\n        }\n    }\n    /**\n     * Circular shift bitset by an offset\n     * @param {Number} number of positions that the bitset that will be shifted to the right.\n     * Using a negative number will result in a left shift.\n     * @returns {Bitset} a new bitset that is rotated by the offset\n     */\n    circularShift(offset) {\n        offset = -offset;\n        const S = this; // source BitSet (this)\n        const MASK_SIGN = 0x7fffffff;\n        const BITS = S.MAX_BIT + 1;\n        const WORDS = S.arr.length;\n        const BITS_LAST_WORD = BITS_PER_INT - (WORDS * BITS_PER_INT - BITS);\n        const T = new BitSet(BITS); // target BitSet (the shifted bitset)\n        let t = 0; // (s)ource and (t)arget word indices\n        let j = 0; // current bit indices for source (i) and target (j) words\n        let z = 0; // bit index for entire sequence.\n        offset = (BITS + (offset % BITS)) % BITS; // positive, within length\n        let s = ~~(offset / BITS_PER_INT) % WORDS;\n        let i = offset % BITS_PER_INT;\n        while (z < BITS) {\n            const sourceWordLength = s === WORDS - 1 ? BITS_LAST_WORD : BITS_PER_INT;\n            let bits = S.arr[s];\n            if (i > 0) {\n                bits = bits >>> i;\n            }\n            if (j > 0) {\n                bits = bits << j;\n            }\n            T.arr[t] = T.arr[t] | bits;\n            const bitsAdded = Math.min(BITS_PER_INT - j, sourceWordLength - i);\n            z += bitsAdded;\n            j += bitsAdded;\n            if (j >= BITS_PER_INT) {\n                T.arr[t] = T.arr[t] & MASK_SIGN;\n                j = 0;\n                t++;\n            }\n            i += bitsAdded;\n            if (i >= sourceWordLength) {\n                i = 0;\n                s++;\n            }\n            if (s >= WORDS) {\n                s -= WORDS;\n            }\n        }\n        T.arr[WORDS - 1] =\n            T.arr[WORDS - 1] & (MASK_SIGN >>> (BITS_PER_INT - BITS_LAST_WORD));\n        return T;\n    }\n    /**\n     * Get the cardinality (count of set bits) for the entire bitset\n     * @returns {number} cardinality\n     */\n    getCardinality() {\n        let setCount = 0;\n        for (let i = this.arr.length - 1; i >= 0; i--) {\n            let j = this.arr[i];\n            j = j - ((j >> 1) & 0x55555555);\n            j = (j & 0x33333333) + ((j >> 2) & 0x33333333);\n            setCount += (((j + (j >> 4)) & 0x0f0f0f0f) * 0x01010101) >> 24;\n        }\n        return setCount;\n    }\n    /**\n     * Get the indices of all set bits. Useful for debugging, uses `forEach` internally\n     * @returns {Array} Indices of all set bits\n     */\n    getIndices() {\n        const indices = [];\n        this.forEach((i) => {\n            indices.push(i);\n        });\n        return indices;\n    }\n    /**\n     * Checks if one bitset is subset of another. Same thing can be done using _and_ operation and equality check,\n     * but then new BitSet would be created, and if one is only interested in yes/no information it would be a waste\n     * of memory and additional GC strain.\n     * @param {BitSet} bs a bitset to check\n     * @returns {Boolean} `true` if provided bitset is a subset of this bitset, `false` otherwise\n     */\n    isSubsetOf(bs) {\n        const arr1 = this.arr;\n        const arr2 = bs.arr;\n        const len = arr1.length;\n        for (let i = 0; i < len; i++) {\n            if ((arr1[i] & arr2[i]) !== arr1[i]) {\n                return false;\n            }\n        }\n        return true;\n    }\n    /**\n     * Quickly determine if a bitset is empty\n     * @returns {boolean} true if the entire bitset is empty, else false\n     */\n    isEmpty() {\n        let i;\n        let arr;\n        arr = this.arr;\n        for (i = 0; i < arr.length; i++) {\n            if (arr[i]) {\n                return false;\n            }\n        }\n        return true;\n    }\n    /**\n     *\n     * Quickly determine if both bitsets are equal (faster than checking if the XOR of the two is === 0).\n     * Both bitsets must have the same number of words, no length check is performed to prevent and overflow.\n     * @param {BitSet} bs\n     * @returns {boolean} true if the entire bitset is empty, else false\n     */\n    isEqual(bs) {\n        let i;\n        for (i = 0; i < this.arr.length; i++) {\n            if (this.arr[i] !== bs.arr[i]) {\n                return false;\n            }\n        }\n        return true;\n    }\n    /**\n     * Get a string representation of the entire bitset, including leading 0s (useful for debugging)\n     * @returns {string} a base 2 representation of the entire bitset\n     */\n    toString() {\n        let i;\n        let str;\n        let fullString = '';\n        for (i = this.arr.length - 1; i >= 0; i--) {\n            str = this.arr[i].toString(2);\n            fullString += ('0000000000000000000000000000000' + str).slice(-BITS_PER_INT);\n        }\n        return fullString;\n    }\n    /**\n     * Find first set bit (useful for processing queues, breadth-first tree searches, etc.)\n     * @param {number} startWord the word to start with (only used internally by nextSetBit)\n     * @returns {number} the index of the first set bit in the bitset, or -1 if not found\n     */\n    ffs(startWord = 0) {\n        let setVal;\n        let i;\n        let fs = -1;\n        for (i = startWord; i < this.arr.length; i++) {\n            setVal = this.arr[i];\n            if (setVal === 0) {\n                continue;\n            }\n            fs = lsb(setVal) + i * BITS_PER_INT;\n            break;\n        }\n        return fs <= this.MAX_BIT ? fs : -1;\n    }\n    /**\n     * Find first zero (unset bit)\n     * @param {number} startWord the word to start with (only used internally by nextUnsetBit)\n     * @returns {number} the index of the first unset bit in the bitset, or -1 if not found\n     */\n    ffz(startWord) {\n        let i;\n        let setVal;\n        let fz = -1;\n        startWord = startWord || 0;\n        for (i = startWord; i < this.arr.length; i++) {\n            setVal = this.arr[i];\n            if (setVal === 0x7fffffff) {\n                continue;\n            }\n            setVal ^= 0x7fffffff;\n            fz = lsb(setVal) + i * BITS_PER_INT;\n            break;\n        }\n        return fz <= this.MAX_BIT ? fz : -1;\n    }\n    /**\n     *\n     * Find last set bit\n     * @param {number} startWord the word to start with (only used internally by previousSetBit)\n     * @returns {number} the index of the last set bit in the bitset, or -1 if not found\n     */\n    fls(startWord = this.arr.length - 1) {\n        let i;\n        let setVal;\n        let ls = -1;\n        for (i = startWord; i >= 0; i--) {\n            setVal = this.arr[i];\n            if (setVal === 0) {\n                continue;\n            }\n            ls = msb(setVal) + i * BITS_PER_INT;\n            break;\n        }\n        return ls;\n    }\n    /**\n     *\n     * Find last zero (unset bit)\n     * @param {number} startWord the word to start with (only used internally by previousUnsetBit)\n     * @returns {number} the index of the last unset bit in the bitset, or -1 if not found\n     */\n    flz(startWord) {\n        let i;\n        let setVal;\n        let ls = -1;\n        if (startWord === undefined) {\n            startWord = this.arr.length - 1;\n        }\n        for (i = startWord; i >= 0; i--) {\n            setVal = this.arr[i];\n            if (i === this.arr.length - 1) {\n                const wordIdx = this.MAX_BIT % BITS_PER_INT;\n                const unusedBitCount = BITS_PER_INT - wordIdx - 1;\n                setVal |= ((1 << unusedBitCount) - 1) << (wordIdx + 1);\n            }\n            if (setVal === 0x7fffffff) {\n                continue;\n            }\n            setVal ^= 0x7fffffff;\n            ls = msb(setVal) + i * BITS_PER_INT;\n            break;\n        }\n        return ls;\n    }\n    /**\n     * Find first set bit, starting at a given index\n     * @param {number} idx the starting index for the next set bit\n     * @returns {number} the index of the next set bit >= idx, or -1 if not found\n     */\n    nextSetBit(idx) {\n        const startWord = this.getWord(idx);\n        if (startWord === -1) {\n            return -1;\n        }\n        const wordIdx = idx % BITS_PER_INT;\n        const len = BITS_PER_INT - wordIdx;\n        const mask = ((1 << len) - 1) << wordIdx;\n        const reducedWord = this.arr[startWord] & mask;\n        if (reducedWord > 0) {\n            return lsb(reducedWord) + startWord * BITS_PER_INT;\n        }\n        return this.ffs(startWord + 1);\n    }\n    /**\n     * Find first unset bit, starting at a given index\n     * @param {number} idx the starting index for the next unset bit\n     * @returns {number} the index of the next unset bit >= idx, or -1 if not found\n     */\n    nextUnsetBit(idx) {\n        const startWord = this.getWord(idx);\n        if (startWord === -1) {\n            return -1;\n        }\n        const mask = (1 << idx % BITS_PER_INT) - 1;\n        const reducedWord = this.arr[startWord] | mask;\n        if (reducedWord === 0x7fffffff) {\n            return this.ffz(startWord + 1);\n        }\n        return lsb(0x7fffffff ^ reducedWord) + startWord * BITS_PER_INT;\n    }\n    /**\n     * Find last set bit, up to a given index\n     * @param {number} idx the starting index for the next unset bit (going in reverse)\n     * @returns {number} the index of the next unset bit <= idx, or -1 if not found\n     */\n    previousSetBit(idx) {\n        const startWord = this.getWord(idx);\n        if (startWord === -1) {\n            return -1;\n        }\n        const mask = 0x7fffffff >>> (BITS_PER_INT - (idx % BITS_PER_INT) - 1);\n        const reducedWord = this.arr[startWord] & mask;\n        if (reducedWord > 0) {\n            return msb(reducedWord) + startWord * BITS_PER_INT;\n        }\n        return this.fls(startWord - 1);\n    }\n    /**\n     * Find last unset bit, up to a given index\n     * @param {number} idx the starting index for the next unset bit (going in reverse)\n     * @returns {number} the index of the next unset bit <= idx, or -1 if not found\n     */\n    previousUnsetBit(idx) {\n        const startWord = this.getWord(idx);\n        if (startWord === -1) {\n            return -1;\n        }\n        const wordIdx = idx % BITS_PER_INT;\n        const mask = ((1 << (BITS_PER_INT - wordIdx - 1)) - 1) << (wordIdx + 1);\n        const reducedWord = this.arr[startWord] | mask;\n        if (reducedWord === 0x7fffffff) {\n            return this.flz(startWord - 1);\n        }\n        return msb(0x7fffffff ^ reducedWord) + startWord * BITS_PER_INT;\n    }\n    /**\n     *\n     * @param {number} idx position of bit in bitset\n     * @returns {number} the word where the index is located, or -1 if out of range\n     * @private\n     */\n    getWord(idx) {\n        return idx < 0 || idx > this.MAX_BIT ? -1 : ~~(idx / BITS_PER_INT);\n    }\n    /**\n     * Shared function for setting, unsetting, or toggling a range of bits\n     * @param {number} from the starting index of the range to set\n     * @param {number} to the ending index of the range to set\n     * @param {Function} func function to run (set, unset, or toggle)\n     * @returns {boolean} true if set was successful, else false\n     * @private\n     */\n    // tslint:disable-next-line: ban-types\n    doRange(from, to, func) {\n        let i;\n        let curStart;\n        let curEnd;\n        let len;\n        if (to < from) {\n            to ^= from;\n            from ^= to;\n            to ^= from;\n        }\n        const startWord = this.getWord(from);\n        const endWord = this.getWord(to);\n        if (startWord === -1 || endWord === -1) {\n            return false;\n        }\n        for (i = startWord; i <= endWord; i++) {\n            curStart = i === startWord ? from % BITS_PER_INT : 0;\n            curEnd = i === endWord ? to % BITS_PER_INT : BITS_PER_INT - 1;\n            len = curEnd - curStart + 1;\n            this.arr[i] = func(this.arr[i], len, curStart);\n        }\n        return true;\n    }\n    /**\n     * Both bitsets must have the same number of words, no length check is performed to prevent and overflow.\n     * @param {BitSet | Number} bsOrIdx a bitset or single index to check (useful for LP, DP problems)\n     * @param {Function} func the operation to perform (and, or, xor)\n     * @returns {BitSet} a new bitset that is the bitwise operation of the two\n     * @private\n     */\n    // tslint:disable-next-line: ban-types\n    op(bsOrIdx, func) {\n        let i;\n        let arr1;\n        let arr2;\n        let len;\n        let newBS;\n        let word;\n        arr1 = this.arr;\n        if (typeof bsOrIdx === 'number') {\n            word = this.getWord(bsOrIdx);\n            newBS = this.clone();\n            if (word !== -1) {\n                newBS.arr[word] = func(arr1[word], 1 << bsOrIdx % BITS_PER_INT);\n            }\n        }\n        else {\n            arr2 = bsOrIdx.arr;\n            len = arr1.length;\n            newBS = new BitSet(this.MAX_BIT + 1);\n            for (i = 0; i < len; i++) {\n                newBS.arr[i] = func(arr1[i], arr2[i]);\n            }\n        }\n        return newBS;\n    }\n}\n/**\n *\n * Returns the least signifcant bit, or 0 if none set, so a prior check to see if the word > 0 is required\n * @param {number} word the current array\n * @returns {number} the index of the least significant bit in the current array\n */\nexport function lsb(word) {\n    return multiplyDeBruijnBitPosition[((word & -word) * 0x077cb531) >>> 27];\n}\n/**\n * Returns the least signifcant bit, or 0 if none set, so a prior check to see if the word > 0 is required\n * @param word the current array\n * @returns {number} the index of the most significant bit in the current array\n */\nexport function msb(word) {\n    word |= word >> 1;\n    word |= word >> 2;\n    word |= word >> 4;\n    word |= word >> 8;\n    word |= word >> 16;\n    word = (word >> 1) + 1;\n    return multiplyDeBruijnBitPosition[(word * 0x077cb531) >>> 27];\n}\nexport function toggleFunc(word, len, curStart) {\n    const mask = ((1 << len) - 1) << curStart;\n    return word ^ mask;\n}\nexport function setFunc(word, len, curStart) {\n    const mask = ((1 << len) - 1) << curStart;\n    return word | mask;\n}\nexport function unsetFunc(word, len, curStart) {\n    const mask = 0x7fffffff ^ (((1 << len) - 1) << curStart);\n    return word & mask;\n}\nexport function and(word1, word2) {\n    return word1 & word2;\n}\nexport function or(word1, word2) {\n    return word1 | word2;\n}\nexport function xor(word1, word2) {\n    return word1 ^ word2;\n}\n","import { BitSet } from './bitset';\nexport class ComponentMap {\n    constructor() {\n        this.bitmask = new BitSet(0);\n        this.map = new Map();\n    }\n    get(ctor) {\n        const component = this.map.get(ctor);\n        return component != null ? component : undefined;\n    }\n    set(...components) {\n        let mask = new BitSet(0);\n        for (const component of components) {\n            if (this.map.has(component.constructor) === false) {\n                mask = mask.or(component.constructor.bitmask);\n            }\n            this.map.set(component.constructor, component);\n        }\n        this.bitmask = this.bitmask.or(mask);\n    }\n    remove(...componentCtors) {\n        let mask = new BitSet(0);\n        for (const componentCtor of componentCtors) {\n            if (this.map.has(componentCtor)) {\n                mask = mask.or(componentCtor.bitmask);\n            }\n            this.map.delete(componentCtor);\n        }\n        this.bitmask = this.bitmask.xor(mask);\n    }\n    clear() {\n        this.map.clear();\n        this.bitmask.clear();\n    }\n    keys() {\n        return this.map.keys();\n    }\n    has(componentCtor) {\n        return this.map.has(componentCtor);\n    }\n    get size() {\n        return this.map.size;\n    }\n}\n","import { ComponentMap } from './component-map';\nimport { Entity } from './entity';\nexport function* entityIdGenerator() {\n    let id = 0;\n    while (true) {\n        ++id;\n        yield id;\n    }\n}\n/**\n * Container for Systems and Entities\n */\nexport class World {\n    /**\n     * Create a new World instance\n     * @param idGenerator Unique entity id generator\n     */\n    constructor(idGenerator = entityIdGenerator()) {\n        this.idGenerator = idGenerator;\n        this.systems = [];\n        this.systemsToRemove = [];\n        this.systemsToAdd = [];\n        this.entities = new Map();\n        this.deletedEntities = new Set();\n        this.componentEntities = new Map();\n    }\n    /**\n     * Update all world systems\n     * @param dt Delta time\n     */\n    update(dt) {\n        this.updateSystems(dt);\n    }\n    createEntity() {\n        if (this.deletedEntities.size > 0) {\n            const entity = this.deletedEntities.values().next().value;\n            this.deletedEntities.delete(entity);\n            return entity;\n        }\n        const entity = new Entity(this.idGenerator.next().value);\n        this.entities.set(entity, new ComponentMap());\n        return entity;\n    }\n    /**\n     * Delete an entity from the world. Entities can be recycled so do not rely\n     * on the deleted entity reference after deleting it.\n     * @param entity Entity to delete\n     */\n    deleteEntity(entity) {\n        if (this.deletedEntities.has(entity)) {\n            return false;\n        }\n        if (this.entities.has(entity)) {\n            const componentMap = this.entities.get(entity);\n            for (const ctor of componentMap.keys()) {\n                this.componentEntities.get(ctor).delete(entity);\n            }\n            componentMap.clear();\n            this.deletedEntities.add(entity);\n            return true;\n        }\n        return false;\n    }\n    findEntity(...componentCtors) {\n        if (componentCtors.length === 0) {\n            return undefined;\n        }\n        const hasAllComponents = componentCtors.every(ctor => this.componentEntities.has(ctor));\n        if (hasAllComponents === false) {\n            return undefined;\n        }\n        const componentSets = componentCtors.map(ctor => this.componentEntities.get(ctor));\n        const smallestComponentSet = componentSets.reduce((smallest, set) => {\n            if (smallest == null) {\n                smallest = set;\n            }\n            else if (set.size < smallest.size) {\n                smallest = set;\n            }\n            return smallest;\n        });\n        const otherComponentSets = componentSets.filter(set => set !== smallestComponentSet);\n        for (const entity of smallestComponentSet.values()) {\n            const hasAll = otherComponentSets.every(set => set.has(entity));\n            if (hasAll === true) {\n                return entity;\n            }\n        }\n    }\n    addEntityComponents(entity, ...components) {\n        if (this.deletedEntities.has(entity)) {\n            throw new Error('Entity has been deleted');\n        }\n        const entityComponents = this.entities.get(entity);\n        if (entityComponents != null) {\n            entityComponents.set(...components);\n            for (const componentCtor of entityComponents.keys()) {\n                if (this.componentEntities.has(componentCtor)) {\n                    this.componentEntities.get(componentCtor).add(entity);\n                }\n                else {\n                    this.componentEntities.set(componentCtor, new Set([entity]));\n                }\n            }\n        }\n        return this;\n    }\n    getEntityComponents(entity) {\n        if (this.deletedEntities.has(entity)) {\n            return undefined;\n        }\n        return this.entities.get(entity);\n    }\n    removeEntityComponents(entity, ...components) {\n        if (this.deletedEntities.has(entity)) {\n            throw new Error('Entity has been deleted');\n        }\n        const entityComponents = this.entities.get(entity);\n        if (entityComponents != null) {\n            entityComponents.remove(...components.map(component => component.constructor));\n            components.forEach(component => {\n                const ctor = component.constructor;\n                if (this.componentEntities.has(ctor)) {\n                    this.componentEntities.get(ctor).delete(entity);\n                }\n            });\n        }\n        return this;\n    }\n    /**\n     * Register a system for addition. Systems are executed linearly in the order added.\n     * @param system System\n     */\n    addSystem(system) {\n        this.systemsToAdd.push(system);\n    }\n    /**\n     * Register a system for removal.\n     * @param system System\n     */\n    removeSystem(system) {\n        this.systemsToRemove.push(system);\n    }\n    updateSystems(dt) {\n        if (this.systemsToRemove.length > 0) {\n            this.systems = this.systems.filter(existing => this.systemsToRemove.includes(existing));\n            this.systemsToRemove = [];\n        }\n        if (this.systemsToAdd.length > 0) {\n            this.systemsToAdd.forEach(newSystem => {\n                if (this.systems.includes(newSystem) === false) {\n                    this.systems.push(newSystem);\n                }\n            });\n            this.systemsToAdd = [];\n        }\n        for (const system of this.systems) {\n            system.update(this, dt);\n        }\n    }\n    view(...componentCtors) {\n        const entities = new Map();\n        if (componentCtors.length === 0) {\n            return entities;\n        }\n        const componentSets = componentCtors.map(ctor => {\n            if (this.componentEntities.has(ctor) === false) {\n                throw new Error(`Component ${ctor.name} not found`);\n            }\n            return this.componentEntities.get(ctor);\n        });\n        const smallestComponentSet = componentSets.reduce((smallest, set) => {\n            if (smallest == null) {\n                smallest = set;\n            }\n            else if (set.size < smallest.size) {\n                smallest = set;\n            }\n            return smallest;\n        });\n        const otherComponentSets = componentSets.filter(set => set !== smallestComponentSet);\n        for (const entity of smallestComponentSet) {\n            const hasAll = otherComponentSets.every(set => set.has(entity));\n            if (hasAll === true) {\n                entities.set(entity, this.getEntityComponents(entity));\n            }\n        }\n        return entities;\n    }\n}\n","import { BitSet } from './bitset';\nfunction* bitmaskGenerator() {\n    let n = 1;\n    while (true) {\n        const mask = new BitSet(n);\n        mask.set(n - 1);\n        ++n;\n        yield mask;\n    }\n}\nexport class Component {\n    constructor() {\n        // tslint:disable-next-line: variable-name\n        this.__component = true;\n    }\n    static get bitmask() {\n        if (this._bitmask == null) {\n            this._bitmask = this._bitmaskGenerator.next().value;\n        }\n        return this._bitmask;\n    }\n}\nComponent._bitmaskGenerator = bitmaskGenerator();\n","/*\n * A main loop useful for games and other animated applications.\n */\n(function(root) {\n\n    // The amount of time (in milliseconds) to simulate each time update()\n    // runs. See `MainLoop.setSimulationTimestep()` for details.\nvar simulationTimestep = 1000 / 60,\n\n    // The cumulative amount of in-app time that hasn't been simulated yet.\n    // See the comments inside animate() for details.\n    frameDelta = 0,\n\n    // The timestamp in milliseconds of the last time the main loop was run.\n    // Used to compute the time elapsed between frames.\n    lastFrameTimeMs = 0,\n\n    // An exponential moving average of the frames per second.\n    fps = 60,\n\n    // A factor that affects how heavily to weight more recent seconds'\n    // performance when calculating the average frames per second. Valid values\n    // range from zero to one inclusive. Higher values result in weighting more\n    // recent seconds more heavily.\n    fpsAlpha = 0.9,\n\n    // The minimum duration between updates to the frames-per-second estimate.\n    // Higher values increase accuracy, but result in slower updates.\n    fpsUpdateInterval = 1000,\n\n    // The timestamp (in milliseconds) of the last time the `fps` moving\n    // average was updated.\n    lastFpsUpdate = 0,\n\n    // The number of frames delivered since the last time the `fps` moving\n    // average was updated (i.e. since `lastFpsUpdate`).\n    framesSinceLastFpsUpdate = 0,\n\n    // The number of times update() is called in a given frame. This is only\n    // relevant inside of animate(), but a reference is held externally so that\n    // this variable is not marked for garbage collection every time the main\n    // loop runs.\n    numUpdateSteps = 0,\n\n    // The minimum amount of time in milliseconds that must pass since the last\n    // frame was executed before another frame can be executed. The\n    // multiplicative inverse caps the FPS (the default of zero means there is\n    // no cap).\n    minFrameDelay = 0,\n\n    // Whether the main loop is running.\n    running = false,\n\n    // `true` if `MainLoop.start()` has been called and the most recent time it\n    // was called has not been followed by a call to `MainLoop.stop()`. This is\n    // different than `running` because there is a delay of a few milliseconds\n    // after `MainLoop.start()` is called before the application is considered\n    // \"running.\" This delay is due to waiting for the next frame.\n    started = false,\n\n    // Whether the simulation has fallen too far behind real time.\n    // Specifically, `panic` will be set to `true` if too many updates occur in\n    // one frame. This is only relevant inside of animate(), but a reference is\n    // held externally so that this variable is not marked for garbage\n    // collection every time the main loop runs.\n    panic = false,\n\n    // The object most likely to have `requestAnimationFrame` attached is\n    // `window`, if it's available in this environment. Otherwise, fall back to\n    // the root context.\n    windowOrRoot = typeof window === 'object' ? window : root,\n\n    // The function that runs the main loop. The unprefixed version of\n    // `window.requestAnimationFrame()` is available in all modern browsers\n    // now, but node.js doesn't have it, so fall back to timers. The polyfill\n    // is adapted from the MIT-licensed\n    // https://github.com/underscorediscovery/realtime-multiplayer-in-html5\n    requestAnimationFrame = windowOrRoot.requestAnimationFrame || (function() {\n        var lastTimestamp = Date.now(),\n            now,\n            timeout;\n        return function(callback) {\n            now = Date.now();\n            // The next frame should run no sooner than the simulation allows,\n            // but as soon as possible if the current frame has already taken\n            // more time to run than is simulated in one timestep.\n            timeout = Math.max(0, simulationTimestep - (now - lastTimestamp));\n            lastTimestamp = now + timeout;\n            return setTimeout(function() {\n                callback(now + timeout);\n            }, timeout);\n        };\n    })(),\n\n    // The function that stops the main loop. The unprefixed version of\n    // `window.cancelAnimationFrame()` is available in all modern browsers now,\n    // but node.js doesn't have it, so fall back to timers.\n    cancelAnimationFrame = windowOrRoot.cancelAnimationFrame || clearTimeout,\n\n    // In all major browsers, replacing non-specified functions with NOOPs\n    // seems to be as fast or slightly faster than using conditions to only\n    // call the functions if they are specified. This is probably due to empty\n    // functions being optimized away. http://jsperf.com/noop-vs-condition\n    NOOP = function() {},\n\n    // A function that runs at the beginning of the main loop.\n    // See `MainLoop.setBegin()` for details.\n    begin = NOOP,\n\n    // A function that runs updates (i.e. AI and physics).\n    // See `MainLoop.setUpdate()` for details.\n    update = NOOP,\n\n    // A function that draws things on the screen.\n    // See `MainLoop.setDraw()` for details.\n    draw = NOOP,\n\n    // A function that runs at the end of the main loop.\n    // See `MainLoop.setEnd()` for details.\n    end = NOOP,\n\n    // The ID of the currently executing frame. Used to cancel frames when\n    // stopping the loop.\n    rafHandle;\n\n/**\n * Manages the main loop that runs updates and rendering.\n *\n * The main loop is a core part of any application in which state changes\n * even if no events are handled. In games, it is typically responsible for\n * computing physics and AI as well as drawing the result on the screen.\n *\n * The body of this particular loop is run every time the browser is ready to\n * paint another frame. The frequency with which this happens depends primarily\n * on the monitor's refresh rate, which is typically 60 frames per second. Most\n * applications aim to run at 60 FPS for this reason, meaning that the main\n * loop runs about once every 16.7 milliseconds. With this target, everything\n * that happens in the main loop (e.g. all updates and drawing) needs to occur\n * within the \"budget\" of 16.7 milliseconds.  See\n * `MainLoop.setSimulationTimestep()` for more information about typical\n * monitor refresh rates and frame rate targets.\n *\n * The main loop can be started and stopped, but there can only be one MainLoop\n * (except that each Web Worker can have its own MainLoop). There are four main\n * parts of the loop: {@link #setBegin begin}(), {@link #setUpdate update}(),\n * {@link #setDraw draw}(), and {@link #setEnd end}(), in that order. See the\n * functions that set each of them for descriptions of what they are used for.\n * Note that update() can run zero or more times per loop.\n *\n * @class MainLoop\n */\nroot.MainLoop = {\n    /**\n     * Gets how many milliseconds should be simulated by every run of update().\n     *\n     * See `MainLoop.setSimulationTimestep()` for details on this value.\n     *\n     * @return {Number}\n     *   The number of milliseconds that should be simulated by every run of\n     *   {@link #setUpdate update}().\n     */\n    getSimulationTimestep: function() {\n        return simulationTimestep;\n    },\n\n    /**\n     * Sets how many milliseconds should be simulated by every run of update().\n     *\n     * The perceived frames per second (FPS) is effectively capped at the\n     * multiplicative inverse of the simulation timestep. That is, if the\n     * timestep is 1000 / 60 (which is the default), then the maximum perceived\n     * FPS is effectively 60. Decreasing the timestep increases the maximum\n     * perceived FPS at the cost of running {@link #setUpdate update}() more\n     * times per frame at lower frame rates. Since running update() more times\n     * takes more time to process, this can actually slow down the frame rate.\n     * Additionally, if the amount of time it takes to run update() exceeds or\n     * very nearly exceeds the timestep, the application will freeze and crash\n     * in a spiral of death (unless it is rescued; see `MainLoop.setEnd()` for\n     * an explanation of what can be done if a spiral of death is occurring).\n     *\n     * The exception to this is that interpolating between updates for each\n     * render can increase the perceived frame rate and reduce visual\n     * stuttering. See `MainLoop.setDraw()` for an explanation of how to do\n     * this.\n     *\n     * If you are considering decreasing the simulation timestep in order to\n     * raise the maximum perceived FPS, keep in mind that most monitors can't\n     * display more than 60 FPS. Whether humans can tell the difference among\n     * high frame rates depends on the application, but for reference, film is\n     * usually displayed at 24 FPS, other videos at 30 FPS, most games are\n     * acceptable above 30 FPS, and virtual reality might require 75 FPS to\n     * feel natural. Some gaming monitors go up to 144 FPS. Setting the\n     * timestep below 1000 / 144 is discouraged and below 1000 / 240 is\n     * strongly discouraged. The default of 1000 / 60 is good in most cases.\n     *\n     * The simulation timestep should typically only be changed at\n     * deterministic times (e.g. before the main loop starts for the first\n     * time, and not in response to user input or slow frame rates) to avoid\n     * introducing non-deterministic behavior. The update timestep should be\n     * the same for all players/users in multiplayer/multi-user applications.\n     *\n     * See also `MainLoop.getSimulationTimestep()`.\n     *\n     * @param {Number} timestep\n     *   The number of milliseconds that should be simulated by every run of\n     *   {@link #setUpdate update}().\n     */\n    setSimulationTimestep: function(timestep) {\n        simulationTimestep = timestep;\n        return this;\n    },\n\n    /**\n     * Returns the exponential moving average of the frames per second.\n     *\n     * @return {Number}\n     *   The exponential moving average of the frames per second.\n     */\n    getFPS: function() {\n        return fps;\n    },\n\n    /**\n     * Gets the maximum frame rate.\n     *\n     * Other factors also limit the FPS; see `MainLoop.setSimulationTimestep`\n     * for details.\n     *\n     * See also `MainLoop.setMaxAllowedFPS()`.\n     *\n     * @return {Number}\n     *   The maximum number of frames per second allowed.\n     */\n    getMaxAllowedFPS: function() {\n        return 1000 / minFrameDelay;\n    },\n\n    /**\n     * Sets a maximum frame rate.\n     *\n     * See also `MainLoop.getMaxAllowedFPS()`.\n     *\n     * @param {Number} [fps=Infinity]\n     *   The maximum number of frames per second to execute. If Infinity or not\n     *   passed, there will be no FPS cap (although other factors do limit the\n     *   FPS; see `MainLoop.setSimulationTimestep` for details). If zero, this\n     *   will stop the loop, and when the loop is next started, it will return\n     *   to the previous maximum frame rate. Passing negative values will stall\n     *   the loop until this function is called again with a positive value.\n     *\n     * @chainable\n     */\n    setMaxAllowedFPS: function(fps) {\n        if (typeof fps === 'undefined') {\n            fps = Infinity;\n        }\n        if (fps === 0) {\n            this.stop();\n        }\n        else {\n            // Dividing by Infinity returns zero.\n            minFrameDelay = 1000 / fps;\n        }\n        return this;\n    },\n\n    /**\n     * Reset the amount of time that has not yet been simulated to zero.\n     *\n     * This introduces non-deterministic behavior if called after the\n     * application has started running (unless it is being reset, in which case\n     * it doesn't matter). However, this can be useful in cases where the\n     * amount of time that has not yet been simulated has grown very large\n     * (for example, when the application's tab gets put in the background and\n     * the browser throttles the timers as a result). In applications with\n     * lockstep the player would get dropped, but in other networked\n     * applications it may be necessary to snap or ease the player/user to the\n     * authoritative state and discard pending updates in the process. In\n     * non-networked applications it may also be acceptable to simply resume\n     * the application where it last left off and ignore the accumulated\n     * unsimulated time.\n     *\n     * @return {Number}\n     *   The cumulative amount of elapsed time in milliseconds that has not yet\n     *   been simulated, but is being discarded as a result of calling this\n     *   function.\n     */\n    resetFrameDelta: function() {\n        var oldFrameDelta = frameDelta;\n        frameDelta = 0;\n        return oldFrameDelta;\n    },\n\n    /**\n     * Sets the function that runs at the beginning of the main loop.\n     *\n     * The begin() function is typically used to process input before the\n     * updates run. Processing input here (in chunks) can reduce the running\n     * time of event handlers, which is useful because long-running event\n     * handlers can sometimes delay frames.\n     *\n     * Unlike {@link #setUpdate update}(), which can run zero or more times per\n     * frame, begin() always runs exactly once per frame. This makes it useful\n     * for any updates that are not dependent on time in the simulation.\n     * Examples include adjusting HUD calculations or performing long-running\n     * updates incrementally. Compared to {@link #setEnd end}(), generally\n     * actions should occur in begin() if they affect anything that\n     * {@link #setUpdate update}() or {@link #setDraw draw}() use.\n     *\n     * @param {Function} begin\n     *   The begin() function.\n     * @param {Number} [begin.timestamp]\n     *   The current timestamp (when the frame started), in milliseconds. This\n     *   should only be used for comparison to other timestamps because the\n     *   epoch (i.e. the \"zero\" time) depends on the engine running this code.\n     *   In engines that support `DOMHighResTimeStamp` (all modern browsers\n     *   except iOS Safari 8) the epoch is the time the page started loading,\n     *   specifically `performance.timing.navigationStart`. Everywhere else,\n     *   including node.js, the epoch is the Unix epoch (1970-01-01T00:00:00Z).\n     * @param {Number} [begin.delta]\n     *   The total elapsed time that has not yet been simulated, in\n     *   milliseconds.\n     */\n    setBegin: function(fun) {\n        begin = fun || begin;\n        return this;\n    },\n\n    /**\n     * Sets the function that runs updates (e.g. AI and physics).\n     *\n     * The update() function should simulate anything that is affected by time.\n     * It can be called zero or more times per frame depending on the frame\n     * rate.\n     *\n     * As with everything in the main loop, the running time of update()\n     * directly affects the frame rate. If update() takes long enough that the\n     * frame rate drops below the target (\"budgeted\") frame rate, parts of the\n     * update() function that do not need to execute between every frame can be\n     * moved into Web Workers. (Various sources on the internet sometimes\n     * suggest other scheduling patterns using setTimeout() or setInterval().\n     * These approaches sometimes offer modest improvements with minimal\n     * changes to existing code, but because JavaScript is single-threaded, the\n     * updates will still block rendering and drag down the frame rate. Web\n     * Workers execute in separate threads, so they free up more time in the\n     * main loop.)\n     *\n     * This script can be imported into a Web Worker using importScripts() and\n     * used to run a second main loop in the worker. Some considerations:\n     *\n     * - Profile your code before doing the work to move it into Web Workers.\n     *   It could be the rendering that is the bottleneck, in which case the\n     *   solution is to decrease the visual complexity of the scene.\n     * - It doesn't make sense to move the *entire* contents of update() into\n     *   workers unless {@link #setDraw draw}() can interpolate between frames.\n     *   The lowest-hanging fruit is background updates (like calculating\n     *   citizens' happiness in a city-building game), physics that doesn't\n     *   affect the scene (like flags waving in the wind), and anything that is\n     *   occluded or happening far off screen.\n     * - If draw() needs to interpolate physics based on activity that occurs\n     *   in a worker, the worker needs to pass the interpolation value back to\n     *   the main thread so that is is available to draw().\n     * - Web Workers can't access the state of the main thread, so they can't\n     *   directly modify objects in your scene. Moving data to and from Web\n     *   Workers is a pain. The fastest way to do it is with Transferable\n     *   Objects: basically, you can pass an ArrayBuffer to a worker,\n     *   destroying the original reference in the process.\n     *\n     * You can read more about Web Workers and Transferable Objects at\n     * [HTML5 Rocks](http://www.html5rocks.com/en/tutorials/workers/basics/).\n     *\n     * @param {Function} update\n     *   The update() function.\n     * @param {Number} [update.delta]\n     *   The amount of time in milliseconds to simulate in the update. In most\n     *   cases this timestep never changes in order to ensure deterministic\n     *   updates. The timestep is the same as that returned by\n     *   `MainLoop.getSimulationTimestep()`.\n     */\n    setUpdate: function(fun) {\n        update = fun || update;\n        return this;\n    },\n\n    /**\n     * Sets the function that draws things on the screen.\n     *\n     * The draw() function gets passed the percent of time that the next run of\n     * {@link #setUpdate update}() will simulate that has actually elapsed, as\n     * a decimal. In other words, draw() gets passed how far between update()\n     * calls it is. This is useful because the time simulated by update() and\n     * the time between draw() calls is usually different, so the parameter to\n     * draw() can be used to interpolate motion between frames to make\n     * rendering appear smoother. To illustrate, if update() advances the\n     * simulation at each vertical bar in the first row below, and draw() calls\n     * happen at each vertical bar in the second row below, then some frames\n     * will have time left over that is not yet simulated by update() when\n     * rendering occurs in draw():\n     *\n     *     update() timesteps:  |  |  |  |  |  |  |  |  |\n     *     draw() calls:        |   |   |   |   |   |   |\n     *\n     * To interpolate motion for rendering purposes, objects' state after the\n     * last update() must be retained and used to calculate an intermediate\n     * state. Note that this means renders will be up to one update() behind.\n     * This is still better than extrapolating (projecting objects' state after\n     * a future update()) which can produce bizarre results. Storing multiple\n     * states can be difficult to set up, and keep in mind that running this\n     * process takes time that could push the frame rate down, so it's often\n     * not worthwhile unless stuttering is visible.\n     *\n     * @param {Function} draw\n     *   The draw() function.\n     * @param {Number} [draw.interpolationPercentage]\n     *   The cumulative amount of time that hasn't been simulated yet, divided\n     *   by the amount of time that will be simulated the next time update()\n     *   runs. Useful for interpolating frames.\n     */\n    setDraw: function(fun) {\n        draw = fun || draw;\n        return this;\n    },\n\n    /**\n     * Sets the function that runs at the end of the main loop.\n     *\n     * Unlike {@link #setUpdate update}(), which can run zero or more times per\n     * frame, end() always runs exactly once per frame. This makes it useful\n     * for any updates that are not dependent on time in the simulation.\n     * Examples include cleaning up any temporary state set up by\n     * {@link #setBegin begin}(), lowering the visual quality if the frame rate\n     * is too low, or performing long-running updates incrementally. Compared\n     * to begin(), generally actions should occur in end() if they use anything\n     * that update() or {@link #setDraw draw}() affect.\n     *\n     * @param {Function} end\n     *   The end() function.\n     * @param {Number} [end.fps]\n     *   The exponential moving average of the frames per second. This is the\n     *   same value returned by `MainLoop.getFPS()`. It can be used to take\n     *   action when the FPS is too low (or to restore to normalcy if the FPS\n     *   moves back up). Examples of actions to take if the FPS is too low\n     *   include exiting the application, lowering the visual quality, stopping\n     *   or reducing activities outside of the main loop like event handlers or\n     *   audio playback, performing non-critical updates less frequently, or\n     *   increasing the simulation timestep (by calling\n     *   `MainLoop.setSimulationTimestep()`). Note that this last option\n     *   results in more time being simulated per update() call, which causes\n     *   the application to behave non-deterministically.\n     * @param {Boolean} [end.panic=false]\n     *   Indicates whether the simulation has fallen too far behind real time.\n     *   Specifically, `panic` will be `true` if too many updates occurred in\n     *   one frame. In networked lockstep applications, the application should\n     *   wait for some amount of time to see if the user can catch up before\n     *   dropping the user. In networked but non-lockstep applications, this\n     *   typically indicates that the user needs to be snapped or eased to the\n     *   current authoritative state. When this happens, it may be convenient\n     *   to call `MainLoop.resetFrameDelta()` to discard accumulated pending\n     *   updates. In non-networked applications, it may be acceptable to allow\n     *   the application to keep running for awhile to see if it will catch up.\n     *   However, this could also cause the application to look like it is\n     *   running very quickly for a few frames as it transitions through the\n     *   intermediate states. An alternative that may be acceptable is to\n     *   simply ignore the unsimulated elapsed time by calling\n     *   `MainLoop.resetFrameDelta()` even though this introduces\n     *   non-deterministic behavior. In all cases, if the application panics\n     *   frequently, this is an indication that the main loop is running too\n     *   slowly. However, most of the time the drop in frame rate will probably\n     *   be noticeable before a panic occurs. To help the application catch up\n     *   after a panic caused by a spiral of death, the same steps can be taken\n     *   that are suggested above if the FPS drops too low.\n     */\n    setEnd: function(fun) {\n        end = fun || end;\n        return this;\n    },\n\n    /**\n     * Starts the main loop.\n     *\n     * Note that the application is not considered \"running\" immediately after\n     * this function returns; rather, it is considered \"running\" after the\n     * application draws its first frame. The distinction is that event\n     * handlers should remain paused until the application is running, even\n     * after `MainLoop.start()` is called. Check `MainLoop.isRunning()` for the\n     * current status. To act after the application starts, register a callback\n     * with requestAnimationFrame() after calling this function and execute the\n     * action in that callback. It is safe to call `MainLoop.start()` multiple\n     * times even before the application starts running and without calling\n     * `MainLoop.stop()` in between, although there is no reason to do this;\n     * the main loop will only start if it is not already started.\n     *\n     * See also `MainLoop.stop()`.\n     */\n    start: function() {\n        if (!started) {\n            // Since the application doesn't start running immediately, track\n            // whether this function was called and use that to keep it from\n            // starting the main loop multiple times.\n            started = true;\n\n            // In the main loop, draw() is called after update(), so if we\n            // entered the main loop immediately, we would never render the\n            // initial state before any updates occur. Instead, we run one\n            // frame where all we do is draw, and then start the main loop with\n            // the next frame.\n            rafHandle = requestAnimationFrame(function(timestamp) {\n                // Render the initial state before any updates occur.\n                draw(1);\n\n                // The application isn't considered \"running\" until the\n                // application starts drawing.\n                running = true;\n\n                // Reset variables that are used for tracking time so that we\n                // don't simulate time passed while the application was paused.\n                lastFrameTimeMs = timestamp;\n                lastFpsUpdate = timestamp;\n                framesSinceLastFpsUpdate = 0;\n\n                // Start the main loop.\n                rafHandle = requestAnimationFrame(animate);\n            });\n        }\n        return this;\n    },\n\n    /**\n     * Stops the main loop.\n     *\n     * Event handling and other background tasks should also be paused when the\n     * main loop is paused.\n     *\n     * Note that pausing in multiplayer/multi-user applications will cause the\n     * player's/user's client to become out of sync. In this case the\n     * simulation should exit, or the player/user needs to be snapped to their\n     * updated position when the main loop is started again.\n     *\n     * See also `MainLoop.start()` and `MainLoop.isRunning()`.\n     */\n    stop: function() {\n        running = false;\n        started = false;\n        cancelAnimationFrame(rafHandle);\n        return this;\n    },\n\n    /**\n     * Returns whether the main loop is currently running.\n     *\n     * See also `MainLoop.start()` and `MainLoop.stop()`.\n     *\n     * @return {Boolean}\n     *   Whether the main loop is currently running.\n     */\n    isRunning: function() {\n        return running;\n    },\n};\n\n/**\n * The main loop that runs updates and rendering.\n *\n * @param {DOMHighResTimeStamp} timestamp\n *   The current timestamp. In practice this is supplied by\n *   requestAnimationFrame at the time that it starts to fire callbacks. This\n *   should only be used for comparison to other timestamps because the epoch\n *   (i.e. the \"zero\" time) depends on the engine running this code. In engines\n *   that support `DOMHighResTimeStamp` (all modern browsers except iOS Safari\n *   8) the epoch is the time the page started loading, specifically\n *   `performance.timing.navigationStart`. Everywhere else, including node.js,\n *   the epoch is the Unix epoch (1970-01-01T00:00:00Z).\n *\n * @ignore\n */\nfunction animate(timestamp) {\n    // Run the loop again the next time the browser is ready to render.\n    // We set rafHandle immediately so that the next frame can be canceled\n    // during the current frame.\n    rafHandle = requestAnimationFrame(animate);\n\n    // Throttle the frame rate (if minFrameDelay is set to a non-zero value by\n    // `MainLoop.setMaxAllowedFPS()`).\n    if (timestamp < lastFrameTimeMs + minFrameDelay) {\n        return;\n    }\n\n    // frameDelta is the cumulative amount of in-app time that hasn't been\n    // simulated yet. Add the time since the last frame. We need to track total\n    // not-yet-simulated time (as opposed to just the time elapsed since the\n    // last frame) because not all actually elapsed time is guaranteed to be\n    // simulated each frame. See the comments below for details.\n    frameDelta += timestamp - lastFrameTimeMs;\n    lastFrameTimeMs = timestamp;\n\n    // Run any updates that are not dependent on time in the simulation. See\n    // `MainLoop.setBegin()` for additional details on how to use this.\n    begin(timestamp, frameDelta);\n\n    // Update the estimate of the frame rate, `fps`. Approximately every\n    // second, the number of frames that occurred in that second are included\n    // in an exponential moving average of all frames per second. This means\n    // that more recent seconds affect the estimated frame rate more than older\n    // seconds.\n    if (timestamp > lastFpsUpdate + fpsUpdateInterval) {\n        // Compute the new exponential moving average.\n        fps =\n            // Divide the number of frames since the last FPS update by the\n            // amount of time that has passed to get the mean frames per second\n            // over that period. This is necessary because slightly more than a\n            // second has likely passed since the last update.\n            fpsAlpha * framesSinceLastFpsUpdate * 1000 / (timestamp - lastFpsUpdate) +\n            (1 - fpsAlpha) * fps;\n\n        // Reset the frame counter and last-updated timestamp since their\n        // latest values have now been incorporated into the FPS estimate.\n        lastFpsUpdate = timestamp;\n        framesSinceLastFpsUpdate = 0;\n    }\n    // Count the current frame in the next frames-per-second update. This\n    // happens after the previous section because the previous section\n    // calculates the frames that occur up until `timestamp`, and `timestamp`\n    // refers to a time just before the current frame was delivered.\n    framesSinceLastFpsUpdate++;\n\n    /*\n     * A naive way to move an object along its X-axis might be to write a main\n     * loop containing the statement `obj.x += 10;` which would move the object\n     * 10 units per frame. This approach suffers from the issue that it is\n     * dependent on the frame rate. In other words, if your application is\n     * running slowly (that is, fewer frames per second), your object will also\n     * appear to move slowly, whereas if your application is running quickly\n     * (that is, more frames per second), your object will appear to move\n     * quickly. This is undesirable, especially in multiplayer/multi-user\n     * applications.\n     *\n     * One solution is to multiply the speed by the amount of time that has\n     * passed between rendering frames. For example, if you want your object to\n     * move 600 units per second, you might write `obj.x += 600 * delta`, where\n     * `delta` is the time passed since the last frame. (For convenience, let's\n     * move this statement to an update() function that takes `delta` as a\n     * parameter.) This way, your object will move a constant distance over\n     * time. However, at low frame rates and high speeds, your object will move\n     * large distances every frame, which can cause it to do strange things\n     * such as move through walls. Additionally, we would like our program to\n     * be deterministic. That is, every time we run the application with the\n     * same input, we would like exactly the same output. If the time between\n     * frames (the `delta`) varies, our output will diverge the longer the\n     * program runs due to accumulated rounding errors, even at normal frame\n     * rates.\n     *\n     * A better solution is to separate the amount of time simulated in each\n     * update() from the amount of time between frames. Our update() function\n     * doesn't need to change; we just need to change the delta we pass to it\n     * so that each update() simulates a fixed amount of time (that is, `delta`\n     * should have the same value each time update() is called). The update()\n     * function can be run multiple times per frame if needed to simulate the\n     * total amount of time passed since the last frame. (If the time that has\n     * passed since the last frame is less than the fixed simulation time, we\n     * just won't run an update() until the the next frame. If there is\n     * unsimulated time left over that is less than our timestep, we'll just\n     * leave it to be simulated during the next frame.) This approach avoids\n     * inconsistent rounding errors and ensures that there are no giant leaps\n     * through walls between frames.\n     *\n     * That is what is done below. It introduces a new problem, but it is a\n     * manageable one: if the amount of time spent simulating is consistently\n     * longer than the amount of time between frames, the application could\n     * freeze and crash in a spiral of death. This won't happen as long as the\n     * fixed simulation time is set to a value that is high enough that\n     * update() calls usually take less time than the amount of time they're\n     * simulating. If it does start to happen anyway, see `MainLoop.setEnd()`\n     * for a discussion of ways to stop it.\n     *\n     * Additionally, see `MainLoop.setUpdate()` for a discussion of performance\n     * considerations.\n     *\n     * Further reading for those interested:\n     *\n     * - http://gameprogrammingpatterns.com/game-loop.html\n     * - http://gafferongames.com/game-physics/fix-your-timestep/\n     * - https://gamealchemist.wordpress.com/2013/03/16/thoughts-on-the-javascript-game-loop/\n     * - https://developer.mozilla.org/en-US/docs/Games/Anatomy\n     */\n    numUpdateSteps = 0;\n    while (frameDelta >= simulationTimestep) {\n        update(simulationTimestep);\n        frameDelta -= simulationTimestep;\n\n        /*\n         * Sanity check: bail if we run the loop too many times.\n         *\n         * One way this could happen is if update() takes longer to run than\n         * the time it simulates, thereby causing a spiral of death. For ways\n         * to avoid this, see `MainLoop.setEnd()`. Another way this could\n         * happen is if the browser throttles serving frames, which typically\n         * occurs when the tab is in the background or the device battery is\n         * low. An event outside of the main loop such as audio processing or\n         * synchronous resource reads could also cause the application to hang\n         * temporarily and accumulate not-yet-simulated time as a result.\n         *\n         * 240 is chosen because, for any sane value of simulationTimestep, 240\n         * updates will simulate at least one second, and it will simulate four\n         * seconds with the default value of simulationTimestep. (Safari\n         * notifies users that the script is taking too long to run if it takes\n         * more than five seconds.)\n         *\n         * If there are more updates to run in a frame than this, the\n         * application will appear to slow down to the user until it catches\n         * back up. In networked applications this will usually cause the user\n         * to get out of sync with their peers, but if the updates are taking\n         * this long already, they're probably already out of sync.\n         */\n        if (++numUpdateSteps >= 240) {\n            panic = true;\n            break;\n        }\n    }\n\n    /*\n     * Render the screen. We do this regardless of whether update() has run\n     * during this frame because it is possible to interpolate between updates\n     * to make the frame rate appear faster than updates are actually\n     * happening. See `MainLoop.setDraw()` for an explanation of how to do\n     * that.\n     *\n     * We draw after updating because we want the screen to reflect a state of\n     * the application that is as up-to-date as possible. (`MainLoop.start()`\n     * draws the very first frame in the application's initial state, before\n     * any updates have occurred.) Some sources speculate that rendering\n     * earlier in the requestAnimationFrame callback can get the screen painted\n     * faster; this is mostly not true, and even when it is, it's usually just\n     * a trade-off between rendering the current frame sooner and rendering the\n     * next frame later.\n     *\n     * See `MainLoop.setDraw()` for details about draw() itself.\n     */\n    draw(frameDelta / simulationTimestep);\n\n    // Run any updates that are not dependent on time in the simulation. See\n    // `MainLoop.setEnd()` for additional details on how to use this.\n    end(fps, panic);\n\n    panic = false;\n}\n\n// AMD support\nif (typeof define === 'function' && define.amd) {\n    define(root.MainLoop);\n}\n// CommonJS support\nelse if (typeof module === 'object' && module !== null && typeof module.exports === 'object') {\n    module.exports = root.MainLoop;\n}\n\n})(this);\n","import { Component } from \"@jakeklassen/ecs\";\n\nexport class Color extends Component {\n  constructor(public color: string) {\n    super();\n  }\n}\n\n","import { Component } from \"@jakeklassen/ecs\";\n\nexport class Rectangle extends Component {\n  constructor(\n    public readonly x: number,\n    public readonly y: number,\n    public readonly width: number,\n    public readonly height: number,\n  ) {\n    super();\n  }\n}\n","import { Component } from \"@jakeklassen/ecs\";\n\nexport class Vector2 extends Component {\n  public static zero() {\n    return new Vector2(0, 0);\n  }\n\n  public x = 0;\n  public y = 0;\n\n  constructor(x = 0, y = 0) {\n    super();\n\n    this.x = x;\n    this.y = y;\n  }\n}\n","import { Component } from '@jakeklassen/ecs';\nimport { Vector2 } from '../vector2';\n\nexport class Transform extends Component {\n  public position = Vector2.zero();\n\n  constructor(position: Vector2 = Vector2.zero()) {\n    super();\n\n    this.position = position;\n  }\n}\n","import { Component } from \"@jakeklassen/ecs\";\n\nexport class Velocity extends Component {\n  constructor(public x = 0, public y = 0) {\n    super();\n  }\n\n  public flipX() {\n    this.x *= -1;\n  }\n\n  public flipY() {\n    this.y *= -1;\n  }\n}\n","export * from './color';\nexport * from './rectangle';\nexport * from './transform';\nexport * from './velocity';\n","import { Component } from '@jakeklassen/ecs';\n\nexport class BallTag extends Component {}\n","// tslint:disable: max-classes-per-file\n\nimport { System, World } from '@jakeklassen/ecs';\nimport * as mainloop from 'mainloop.js';\nimport { Color, Rectangle, Transform, Velocity } from '../shared/components';\nimport { Vector2 } from '../shared/vector2';\nimport { BallTag } from './components/ball-tag';\n\nconst canvas = document.querySelector('#canvas') as HTMLCanvasElement;\nconst ctx = canvas.getContext('2d');\n\nif (ctx == null) {\n  throw new Error('failed to obtain canvas 2d context');\n}\n\nconst world = new World();\nconst ball = world.createEntity();\n\nworld.addEntityComponents(\n  ball,\n  new BallTag(),\n  new Transform(new Vector2(10, 10)),\n  new Velocity(100, 200),\n  new Rectangle(10, 10, 12, 12),\n  new Color('red'),\n);\n\nclass BallMovementSystem extends System {\n  constructor(private readonly viewport: Rectangle) {\n    super();\n  }\n\n  public update(world: World, dt: number) {\n    const ball = world.findEntity(BallTag);\n\n    if (ball == null) {\n      throw new Error('Entity with BallTag not found');\n    }\n\n    const components = world.getEntityComponents(ball)!;\n\n    const rectangle = components.get<Rectangle>(Rectangle)!;\n    const transform = components.get<Transform>(Transform)!;\n    const velocity = components.get<Velocity>(Velocity)!;\n\n    transform.position.x += velocity.x * dt;\n    transform.position.y += velocity.y * dt;\n\n    if (transform.position.x + rectangle.width > this.viewport.width) {\n      transform.position.x = this.viewport.width - rectangle.width;\n      velocity.flipX();\n    } else if (transform.position.x < 0) {\n      transform.position.x = 0;\n      velocity.flipX();\n    }\n\n    if (transform.position.y + rectangle.height > this.viewport.height) {\n      transform.position.y = this.viewport.height - rectangle.height;\n      velocity.flipY();\n    } else if (transform.position.y < 0) {\n      transform.position.y = 0;\n      velocity.flipY();\n    }\n  }\n}\n\nclass RenderingSystem extends System {\n  constructor(private readonly context: CanvasRenderingContext2D) {\n    super();\n  }\n\n  public update(world: World) {\n    this.context.clearRect(0, 0, 640, 480);\n\n    for (const [entity, components] of world.view(\n      Rectangle,\n      Color,\n      Transform,\n    )) {\n      const { color } = components.get(Color) as Color;\n      const { width, height } = components.get(Rectangle) as Rectangle;\n      const transform = components.get(Transform) as Transform;\n\n      this.context.fillStyle = color;\n      this.context.fillRect(\n        transform.position.x,\n        transform.position.y,\n        width,\n        height,\n      );\n    }\n  }\n}\n\nworld.addSystem(\n  new BallMovementSystem(new Rectangle(0, 0, canvas.width, canvas.height)),\n);\nworld.addSystem(new RenderingSystem(ctx));\n\nmainloop\n  .setUpdate((dt: number) => {\n    world.updateSystems(dt / 1000);\n  })\n  .start();\n","var OVERLAY_ID = '__parcel__error__overlay__';\n\nvar OldModule = module.bundle.Module;\n\nfunction Module(moduleName) {\n  OldModule.call(this, moduleName);\n  this.hot = {\n    data: module.bundle.hotData,\n    _acceptCallbacks: [],\n    _disposeCallbacks: [],\n    accept: function (fn) {\n      this._acceptCallbacks.push(fn || function () {});\n    },\n    dispose: function (fn) {\n      this._disposeCallbacks.push(fn);\n    }\n  };\n\n  module.bundle.hotData = null;\n}\n\nmodule.bundle.Module = Module;\nvar checkedAssets, assetsToAccept;\n\nvar parent = module.bundle.parent;\nif ((!parent || !parent.isParcelRequire) && typeof WebSocket !== 'undefined') {\n  var hostname = process.env.HMR_HOSTNAME || location.hostname;\n  var protocol = location.protocol === 'https:' ? 'wss' : 'ws';\n  var ws = new WebSocket(protocol + '://' + hostname + ':' + process.env.HMR_PORT + '/');\n  ws.onmessage = function(event) {\n    checkedAssets = {};\n    assetsToAccept = [];\n\n    var data = JSON.parse(event.data);\n\n    if (data.type === 'update') {\n      var handled = false;\n      data.assets.forEach(function(asset) {\n        if (!asset.isNew) {\n          var didAccept = hmrAcceptCheck(global.parcelRequire, asset.id);\n          if (didAccept) {\n            handled = true;\n          }\n        }\n      });\n\n      // Enable HMR for CSS by default.\n      handled = handled || data.assets.every(function(asset) {\n        return asset.type === 'css' && asset.generated.js;\n      });\n\n      if (handled) {\n        console.clear();\n\n        data.assets.forEach(function (asset) {\n          hmrApply(global.parcelRequire, asset);\n        });\n\n        assetsToAccept.forEach(function (v) {\n          hmrAcceptRun(v[0], v[1]);\n        });\n      } else if (location.reload) { // `location` global exists in a web worker context but lacks `.reload()` function.\n        location.reload();\n      }\n    }\n\n    if (data.type === 'reload') {\n      ws.close();\n      ws.onclose = function () {\n        location.reload();\n      }\n    }\n\n    if (data.type === 'error-resolved') {\n      console.log('[parcel]  Error resolved');\n\n      removeErrorOverlay();\n    }\n\n    if (data.type === 'error') {\n      console.error('[parcel]   ' + data.error.message + '\\n' + data.error.stack);\n\n      removeErrorOverlay();\n\n      var overlay = createErrorOverlay(data);\n      document.body.appendChild(overlay);\n    }\n  };\n}\n\nfunction removeErrorOverlay() {\n  var overlay = document.getElementById(OVERLAY_ID);\n  if (overlay) {\n    overlay.remove();\n  }\n}\n\nfunction createErrorOverlay(data) {\n  var overlay = document.createElement('div');\n  overlay.id = OVERLAY_ID;\n\n  // html encode message and stack trace\n  var message = document.createElement('div');\n  var stackTrace = document.createElement('pre');\n  message.innerText = data.error.message;\n  stackTrace.innerText = data.error.stack;\n\n  overlay.innerHTML = (\n    '<div style=\"background: black; font-size: 16px; color: white; position: fixed; height: 100%; width: 100%; top: 0px; left: 0px; padding: 30px; opacity: 0.85; font-family: Menlo, Consolas, monospace; z-index: 9999;\">' +\n      '<span style=\"background: red; padding: 2px 4px; border-radius: 2px;\">ERROR</span>' +\n      '<span style=\"top: 2px; margin-left: 5px; position: relative;\"></span>' +\n      '<div style=\"font-size: 18px; font-weight: bold; margin-top: 20px;\">' + message.innerHTML + '</div>' +\n      '<pre>' + stackTrace.innerHTML + '</pre>' +\n    '</div>'\n  );\n\n  return overlay;\n\n}\n\nfunction getParents(bundle, id) {\n  var modules = bundle.modules;\n  if (!modules) {\n    return [];\n  }\n\n  var parents = [];\n  var k, d, dep;\n\n  for (k in modules) {\n    for (d in modules[k][1]) {\n      dep = modules[k][1][d];\n      if (dep === id || (Array.isArray(dep) && dep[dep.length - 1] === id)) {\n        parents.push(k);\n      }\n    }\n  }\n\n  if (bundle.parent) {\n    parents = parents.concat(getParents(bundle.parent, id));\n  }\n\n  return parents;\n}\n\nfunction hmrApply(bundle, asset) {\n  var modules = bundle.modules;\n  if (!modules) {\n    return;\n  }\n\n  if (modules[asset.id] || !bundle.parent) {\n    var fn = new Function('require', 'module', 'exports', asset.generated.js);\n    asset.isNew = !modules[asset.id];\n    modules[asset.id] = [fn, asset.deps];\n  } else if (bundle.parent) {\n    hmrApply(bundle.parent, asset);\n  }\n}\n\nfunction hmrAcceptCheck(bundle, id) {\n  var modules = bundle.modules;\n  if (!modules) {\n    return;\n  }\n\n  if (!modules[id] && bundle.parent) {\n    return hmrAcceptCheck(bundle.parent, id);\n  }\n\n  if (checkedAssets[id]) {\n    return;\n  }\n  checkedAssets[id] = true;\n\n  var cached = bundle.cache[id];\n\n  assetsToAccept.push([bundle, id]);\n\n  if (cached && cached.hot && cached.hot._acceptCallbacks.length) {\n    return true;\n  }\n\n  return getParents(global.parcelRequire, id).some(function (id) {\n    return hmrAcceptCheck(global.parcelRequire, id)\n  });\n}\n\nfunction hmrAcceptRun(bundle, id) {\n  var cached = bundle.cache[id];\n  bundle.hotData = {};\n  if (cached) {\n    cached.hot.data = bundle.hotData;\n  }\n\n  if (cached && cached.hot && cached.hot._disposeCallbacks.length) {\n    cached.hot._disposeCallbacks.forEach(function (cb) {\n      cb(bundle.hotData);\n    });\n  }\n\n  delete bundle.cache[id];\n  bundle(id);\n\n  cached = bundle.cache[id];\n  if (cached && cached.hot && cached.hot._acceptCallbacks.length) {\n    cached.hot._acceptCallbacks.forEach(function (cb) {\n      cb();\n    });\n    return true;\n  }\n}\n"]}